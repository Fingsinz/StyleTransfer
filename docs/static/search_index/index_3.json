{"/StyleTransfer/ref-and-notes/gan.html":{"title":"生成对抗网络","content":" title: 生成对抗网络 keywords: GAN desc: GAN文献及笔记 date: 2025 02 01 id: ref_GAN [Generative Adversarial Networks](https://arxiv.org/abs/1406.2661) *Goodfellow I , Pouget Abadie J , Mirza M ,et al.Generative Adversarial Nets[J].MIT Press, 2014.DOI:10.3156/JSOFT.29.5_177_2.* > We propose a new framework for estimating generative models via an adversarial process, in which we simultaneously train two models: a generative model G that captures the data distribution, and a discriminative model D that estimates the probability that a sample came from the training data rather than G. The training procedure for G is to maximize the probability of D making a mistake. This framework corresponds to a minimax two player game. In the space of arbitrary functions G and D, a unique solution exists, with G recovering the training data distribution and D equal to ½ everywhere. In the case where G and D are defined by multilayer perceptrons, the entire system can be trained with backpropagation. There is no need for any Markov chains or unrolled approximate inference networks during either training or generation of samples. Experiments demonstrate the potential of the framework through qualitative and quantitative evaluation of the generated samples. **摘要**：论文提出一个通过对抗过程估计生成模型的新框架。在对抗过程中，同时训练两个模型：一个捕获数据分布的生成器 G，和一个估计样本来自训练数据还是生成器 G 的判别器 D。生成器 G 的训练过程是最大化判别器 D 犯错的概率。这个框架相当于一个极大极小二人博弈游戏。在任意的 G 和 D 函数空间中，存在唯一解，使得生成器 G 能复刻训练集的数据分布，同时判别器 D 对于生成器 G 生成的任意样本作出的判断都是真假参半（真假概率各半）。如果生成器 G 和判别器 D 都定义为多层感知器，那么整个系统可以使用误差反向传播进行训练。在模型的训练过程以及样本的生成中，不需要使用马尔科夫链或者展开的近似推理网络。通过对生成的样本进行定性和定量评估，实验证明了该框架的潜力。 ## GAN 模型 GAN包含两个模型： 1. **生成器（Generator, G）**：将随机噪声映射到数据空间，目标是生成与真实数据分布 $p_{\\text{data}}$ 一致的样本。 2. **判别器（Discriminator, D）**：区分输入样本来自真实数据还是生成器，输出为样本真实性的概率。 两者通过**极小极大博弈**进行训练： 为了学习生成器在数据 $x$ 上的分布 $p_g$，定义输入噪声变量 $p_z(z)$ 的先验，然后将数据空间的映射表示为 $G(z; \\theta_g)$，其中 $G$ 是由具有参数 $\\theta_g$ 的多层感知器表示的可微函数。 定义第二个多层感知器 $D(x; \\theta_d)$，其输出一个标量。$D(x)$ 表示 $x$ 来自真实数据而不是 $p_g$ 的概率。 **训练判别器 D，最大化正确分类训练样本和生成器 G 生成样本的概率；同时训练生成器 G，最小化 $\\log(1−D(G(z)))$，即让生成样本 $G(z)$ 被判别器误判为真实样本（$D(G(z))→1$）**。 综上所述，GAN 的训练过程可表示为： $$ \\min_G \\max_D V(D, G) \\mathbb{E}_{x \\sim p_{\\text{data}}(x)} [\\log D(x)] + \\mathbb{E}_{z \\sim p_z(z)} [\\log(1 D(G(z)))]\\tag{1} $$ 当生成器 G 分布 $p_g p_{data}$，判别器 D 的最优解为 $D^*(x) \\frac{1}{2}$ 时，目标函数达到最小值 $\\log({\\frac{1}{2}}) + \\log(1 \\frac{1}{2}) \\log{4}$。 ## 网络理论 ### 算法步骤 *小批量随机梯度下降，$k$ 为超参数。* ``` for i 1, iterations do for k steps do m 个噪声样本的小批量样本 {z(1),., z(m)}，来自噪声先验 pg(z)。 m 个真实样本的小批量样本 {x(1),., x(m)}，来自真实数据集。 通过公式 2 提升判别器随机梯度来更新判别器。 end for m 个噪声样本的小批量样本 {z(1),., z(m)}，来自噪声先验 pg(z)。 通过公式 3 降低生成器随机梯度来更新生成器。 end for ``` $$ \\nabla_{\\theta_d} \\frac{1}{m} \\sum_{i 1}^m \\left[\\log D(x^{(i)}) + \\log(1 D(G(z^{(i)}))) \\right] \\tag{2} $$ $$ \\nabla_{\\theta_g} \\frac{1}{m} \\sum_{i 1}^m \\log\\left(1 D(G(z^{(i)}))\\right) \\tag{3} $$ 训练过程的巧思： 1. **在 $k$ 步优化判别器 D 和 $1$ 步优化生成器 G 之间交替进行**：在 one step 的内部循环中优化判别器 D 在计算上是不可行的，并且容易在有限的数据集上导致过拟合。 2. **最大化 $\\log D(G(z))$ 代替最小化 $\\log(1−D(G(z)))$ 训练生成器 G**：在生成器 G 效果很差时，判别器 D可以以高置信度拒绝样本，这种情况下，$\\log(1−D(G(z)))$ 不起作用。 原文中提供下图： ![](../static/images/GAN/fig1.png) *注：黑色散点线为真实数据的分布；绿色实线为生成器 $G$ 生成数据的分布；蓝色虚线为判别器 $D$ 的分布，区分黑色散点与绿色实线。最下面的直线为均匀采样 $z$ 的域；其上面的直线是 $x$ 域的一部分。向上的箭头表示 $x G(z)$ 的映射关系。* 图 (a)：对抗接近收敛，$p_g$ 接近 $p_{data}$，判别器部分分类正确（能否分辨出真实数据和生成数据）。 图 (b)：在算法的内部循环中，判别器 D 向着分类数据训练，收敛在 $D^*(x) \\frac {p_{data}(x)}{p_{data}(x) + p_g(x)}$。 图 (c)：更新生成器 $G$ 后，判别器 $D$ 的梯度引导 $G(z)$ 偏向更有可能被归类为真实数据的区域。 图 (d)：经过若干步训练后，如果 $G$ 和 $D$ 有足够的容量，它们会收敛到 $p_g p_{data}$，此时 $D$ 无法区分出真实数据和生成数据，即 $D(x) \\frac {1}{2}$。 ### 解释全局最优解 $p_g p_{data}$ **命题 1.** 对于固定的生成器 $G$，最优判别器 $D$ 为： $$ D^*_G(x) \\frac {p_{data}(x)}{p_{data}(x) + p_g(x)} $$ **证明：** 给定任何生成器 $G$ 的判别器 $D$ 的训练标准是最大化 $V(G, D)$。 $$ V(G,D) \\int_x p_{data}(x) \\log(D(x))dx + \\int_z p_z(z) \\log(1 D(g(z)))dz\\tag{4} $$ 通过变量替换 $G(z) x \\sim p_g(x)$，式(4)改写为： $$ V(G,D) \\int_x \\left[p_{data}(x) \\log(D(x)) + p_g(x) \\log(1 D(x))\\right] dx $$ > *生成器 $G$ 将噪声输入 $z \\sim p_z(z)$ 映射为样本 $x G(z)$，隐式定义了生成样本的分布 $p_g(x)$。当 $z$ 服从噪声先验 $p_z(z)$ 分布时，$x G(z)$ 的分布即为 $p_g(x)$；若 $z \\sim p_z(z)$，则 $x G(z)\\sim p_g(x)$。* > *对于变量替换定理，对于任意函数 $h(x)$，若 $x$ 是随机变量 $z$ 的映射 $x G(z)$，则关于 $z$ 的期望可以转换为关于 $x$ 的期望：$\\mathbb{E}_{z \\sim p_z(z)}[h(G(z))] \\mathbb{E}_{x \\sim p_g(x)}[h(x)]$。* 对于每个样本 $x$，求 $D(x)$ 使得 $V(D,G)$ 最大化。这是一个单变量优化问题，最优解为： $$ D^*_G(x) \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} $$ 将最优判别器代入到目标函数有： $$ \\begin{aligned} C(G) & \\max_D V(G,D)\\\\ & \\mathbb{E}_{x \\sim p_{\\text{data}}} \\left[\\log D^*_G(x) \\right] + \\mathbb{E}_{z \\sim p_z} \\left[\\log(1 D^*_G(G(z))) \\right] \\\\ & \\mathbb{E}_{x \\sim p_{\\text{data}}} \\left[\\log D^*_G(x) \\right] + \\mathbb{E}_{x \\sim p_g} \\left[\\log(1 D^*_G(x)) \\right]\\\\ & \\mathbb{E}_{x \\sim p_{\\text{data}}} \\left[\\log \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} \\right] + \\mathbb{E}_{x \\sim p_g} \\left[\\log \\frac {p_{g}(x)}{p_{data}(x) + p_{g}(x)} \\right] \\end{aligned}\\tag{5} $$ **定理 1.** 当且仅当 $p_g p_{data}$ 时，$C(G)$ 达到的全局最小值 $ \\log 4$。 **证明：** 对于 $p_g p_{data}$，有 $D^*_G(x) \\frac{1}{2}$。因此： $$ C(G) \\mathbb{E}_{x\\sim p_{data}} \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} + \\mathbb{E}_{x\\sim p_{g}} \\frac {p_{g}(x)}{p_{data}(x) + p_{g}(x)} \\log \\frac {1}{2} + \\log \\frac {1}{2} \\log 4 $$ GAN 的优化目标是最小化生成模型分布 $p_g$ 和真实数据分布 $p_{data}$ 之间的差异，将目标函数中的对数概率表达为 KL 散度的形式。引入变形以关联 KL 散度： $$ \\begin{aligned} \\log \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} \\log \\frac {p_{data}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\log 2 \\\\ \\log \\frac {p_{g}(x)}{p_{data}(x) + p_{g}(x)} \\log \\frac {p_{g}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\log 2 \\end{aligned} $$ 所以， $$ \\begin{aligned} C(G) & \\log 4 + \\mathbb{E}_{x\\sim p_{data}} \\left[\\log \\frac {p_{data}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\right] + \\mathbb{E}_{x\\sim p_{g}} \\left[\\log \\frac {p_{g}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\right] \\\\ & \\log 4 + \\text{KL}\\left(p_{data}\\frac{p_{data}+p_g}{2}\\right) + \\text{KL}\\left(p_g\\frac{p_{data}+p_g}{2}\\right) \\\\ & \\log 4 + 2 \\cdot \\text{JSD}(p_{data} p_g) \\end{aligned} $$ >其中，KL 散度是衡量两个分布差异的常见方法，定义为：$\\text{KL}(pq) \\mathbb{E}_{x\\sim p} \\log \\frac {p(x)}{q(x)}$。Jensen Shannon 散度（JSD）是 KL 散度的一个对称版本，是衡量两个分布差异的对称性指标，定义为：$\\text{JSD}(pq) \\frac {1}{2} \\text{KL}(p \\frac {p + q}{2}) + \\frac {1}{2} \\text{KL}(q \\frac {p + q}{2})$。 由于 JSD 非负，当且仅当 $p q$ 时为零，因此： $$ C(G) \\geq \\log 4, 且等号成立当且仅当 p_g p_{data} $$ 证毕。 ### 解释算法收敛性 **命题 2.** 如果生成器 $G$ 和判别器 $D$ 都有足够的容量，并且算法的每一步都允许判别器在给定 $G$ 的情况下达到最优，并更新 $p_g$ 以改进标准 $\\mathbb{E}_{x\\sim p_{data}}[\\log D^*_G(x)] + \\mathbb{E}_{x\\sim p_{g}}[\\log (1 D^*_G(x))]$，则 $p_g$ 收敛到 $p_{data}$。 **证明：** 考虑 $V(G, D) U(p_g, D)$ 作为 $p_g$ 的函数。$U(p_g, D)$ 是凸函数，且全局最优解唯一。通过梯度下降更新 $p_g$，其参数更新方向始终朝向 JSD 减小的方向，从而保证收敛。 ## 代码实验 实验代码如下，详细代码位于[Github](https://github.com/Fingsinz/StyleTransfer/blob/main/src/01.ref_and_note/01.GAN.py)： <details> <summary>GAN MNIST 实验代码</summary> ```python ''' Created on 2025.02.01 @Author: Fingsinz (fingsinz@foxmail.com) @Reference: 1. https://arxiv.org/abs/1406.2661 ''' import time import os import torch import numpy as np import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader from torchvision import datasets, transforms import matplotlib.pyplot as plt # 配置参数 class Config(): data_folder: str './data' # 数据集路径, 此处用 MNIST 做测试 batch_size: int 128 # batch 大小 epochs: int 10 # 训练轮数 lr: float 0.0002 # 学习率 betas: tuple (0.5, 0.999) # Adam 的超参数 k_steps: int 5 # k 值 latent_dim: int 100 # 隐变量维度 device: str 'cuda' if torch.cuda.is_available() else 'cpu' # 生成器 class Generator(nn.Module): def __init__(self, latent_dim): super().__init__() self.model nn.Sequential( nn.Linear(latent_dim, 256), nn.LeakyReLU(0.2), nn.Linear(256, 512), nn.LeakyReLU(0.2), nn.Linear(512, 1024), nn.LeakyReLU(0.2), nn.Linear(1024, 28 * 28), nn.Tanh() ) def forward(self, x): return self.model(x).view( 1, 1, 28, 28) # 判别器 class Discriminator(nn.Module): def __init__(self): super().__init__() self.model nn.Sequential( nn.Flatten(), nn.Linear(28 * 28, 1024), nn.LeakyReLU(0.2, inplace True), nn.Linear(1024, 512), nn.LeakyReLU(0.2, inplace True), nn.Linear(512, 256), nn.LeakyReLU(0.2, inplace True), nn.Linear(256, 1), nn.Sigmoid() ) def forward(self, x): return self.model(x) # GAN 模型 class GAN(): def __init__(self, config): self.config config self.generator Generator(config.latent_dim).to(config.device) self.discriminator Discriminator().to(config.device) self.criterion nn.BCELoss() self.g_optimizer optim.Adam(self.generator.parameters(), lr config.lr, betas config.betas) self.d_optimizer optim.Adam(self.discriminator.parameters(), lr config.lr, betas config.betas) self.real_label 1 self.fake_label 0 def get_data(self): transform transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,)) ]) train_dataset datasets.MNIST(root self.config.data_folder, train True, download True, transform transform) train_loader DataLoader(train_dataset, batch_size self.config.batch_size, shuffle True) return train_loader def train(self): train_loader self.get_data() epochs self.config.epochs g_loss 0 d_real_loss 0 d_fake_loss 0 for epoch in range(epochs): for i, (images, _) in enumerate(train_loader): batch_size images.size(0) images images.to(self.config.device) # 判别器训练 if (i + 1) % self.config.k_steps ! 0: self.d_optimizer.zero_grad() # 训练真实数据 labels torch.full((batch_size,), self.real_label, device self.config.device).float() output self.discriminator(images) loss_real self.criterion(output.view( 1), labels) loss_real.backward() # 训练假数据 z torch.randn(batch_size, self.config.latent_dim, device self.config.device) fake_images self.generator(z) labels.fill_(self.fake_label).float() output self.discriminator(fake_images.detach()) loss_fake self.criterion(output.view( 1), labels) loss_fake.backward() self.d_optimizer.step() d_real_loss loss_real.item() d_fake_loss loss_fake.item() # 判别器训练 # 生成器训练 else: self.g_optimizer.zero_grad() labels.fill_(self.real_label).float() output self.discriminator(fake_images) loss_g self.criterion(output.view( 1), labels) loss_g.backward() self.g_optimizer.step() g_loss loss_g.item() # 生成器训练 if i % 100 0: print(f\"[{time.strftime('%Y %m %d %H:%M:%S', time.localtime())}] \" + f\"Epoch [{epoch}/{epochs}], Step [{i}/{len(train_loader)}], \" f\"D Loss: {d_real_loss:.4f} + {d_fake_loss:.4f}, G Loss: {g_loss:.4f}\") self.save_generated_images(epoch + 1) def save_generated_images(self, epoch): \"\"\" 保存训练效果图片 参数: epoch (int): 当前轮数 \"\"\" z torch.randn(64, self.config.latent_dim, device self.config.device) fake_images self.generator(z) fake_images fake_images.cpu().detach().numpy() fake_images np.transpose(fake_images, (0, 2, 3, 1)) fig, axes plt.subplots(8, 8, figsize (8, 8)) for i in range(8): for j in range(8): axes[i, j].imshow(fake_images[i * 8 + j, :, :, 0], cmap 'gray') axes[i, j].axis('off') if not os.path.exists('gan_generated_images'): os.makedirs('gan_generated_images') plt.savefig(f'./gan_generated_images/epoch_{epoch}.png') plt.close() if __name__ '__main__': config Config() gan GAN(config) gan.train() ``` </details> GAN 对于 MNIST 数据集效果可如下所示： <table> <th>第一轮生成的图片</th> <th>第十轮生成的图片</th> <tr> <td><img src \"../static/images/GAN/epoch_1.png\"></td> <td><img src \"../static/images/GAN/epoch_10.png\"></td> </tr> </table> ## 论文优缺点及未来工作 优点（DeepSeek总结）： 生成样本质量高：GAN生成的图像、音频等数据具有极高的逼真度，尤其在图像生成任务中表现出色（如人脸、艺术作品生成）。生成器通过对抗训练不断优化，以欺骗判别器，最终生成的样本细节丰富、接近真实数据分布。 无需显式建模数据分布：GAN通过对抗过程直接学习数据分布，无需预先定义概率密度函数（如VAE需要假设潜在变量的分布），适用于复杂高维数据（如自然图像）。 生成多样性：在理想情况下，GAN能够覆盖真实数据的所有模式，生成多样化样本。相比之下，某些模型（如朴素自回归模型）可能因逐像素生成导致模式单一化。 无监督学习能力：GAN仅需未标注数据即可训练，适合缺乏标签的场景（如艺术创作、数据增强）。 灵活的应用扩展：GAN框架可轻松扩展为条件生成（cGAN）、图像翻译（CycleGAN）、超分辨率（SRGAN）等任务，适应多种生成需求。 缺点（DeepSeek总结）： 训练不稳定 模式坍缩（Mode Collapse）：生成器可能仅生成少数几种样本，忽略数据多样性。 梯度问题：若判别器过强，生成器梯度消失；若生成器过强，判别器无法提供有效反馈。 评估困难 缺乏显式似然函数，难以直接计算生成样本的概率。 常用指标（如Inception Score、FID）依赖预训练模型，可能无法全面反映生成质量。 超参数敏感：学习率、网络结构、正则化方法等对训练结果影响显著，需反复调参。 理论分析复杂 收敛性难以保证，实际训练可能陷入局部最优。 均衡状态（纳什均衡）在有限模型容量下难以达到。 生成不可控性 生成过程缺乏显式约束，可能产生不合理样本（如人脸扭曲）。 对离散数据（如文本）生成效果较差，因梯度无法通过离散变量传递。 计算资源消耗大：训练高质量GAN需要大量数据和计算资源（如GPU），耗时较长。 未来工作： 更好地理解这种框架，例如在高维空间中的表现； 探索其他算法和数据结构，例如使用卷积神经网络作为掩码器； 探索其他训练方法，例如使用梯度反向传递训练模型； 探索其他损失函数，例如使用KL损失函数； 探索其他训练方法，例如使用GAN训练模型。"},"/StyleTransfer/ref-and-notes/pytorch-basic-workflow.html":{"title":"PyTorch 基本工作流","content":"Reference:[PyTorchWorkflowFundamentals](https://www.learnpytorch.io/01_pytorch_workflow/)*该页面为JupyterNotebook生成，原文件于[Github](https://github.com/Fingsinz/StyleTransfer/tree/main/src/02.pytorch_learning/pytorch basic workflow.ipynb)*#先导入包importtorchfromtorchimportnnimportmatplotlib.pyplotasplttorch.__version__##准备数据集数据可以是很多东西，如一个表格、任何类型的图像、视频、歌曲或播客等音频文件，蛋白质结构，文本等等。机器学习是一个由两部分组成：1.把你的数据转换成数字表示。2.选择或构建一个模型来尽可能地学习数据的表征。获得数据之后，需要将数据划分为训练集、验证集和测试集。类型目的占比使用情况: :: :: :: :训练集模型从这些数据里面学习（比如学习的课程材料）\\~60\\~80%必须有验证集模型会根据这些数据进行调整（比如期末考试前的练习）\\~10\\~20%不必有测试集模型根据这些数据进行评估，以测试它学到了什么（比如期末考试）\\~10\\~20%必须有#创建一个y weight*x+bias的数据集weight 0.7bias 0.3X torch.arange(0,1,0.02).unsqueeze(dim 1)y weight*X+bias#划分训练集和测试集train_split int(0.8*len(X))X_train,y_train X[:train_split],y[:train_split]X_test,y_test X[train_split:],y[train_split:]defplot_predictions(train_data X_train,train_labels y_train,test_data X_test,test_labels y_test,predictions None):plt.figure(figsize (5,3))plt.scatter(train_data,train_labels,c \"b\",s 4,label \"Trainingdata\")plt.scatter(test_data,test_labels,c \"g\",s 4,label \"Testingdata\")ifpredictionsisnotNone:plt.scatter(test_data,predictions,c \"r\",s 4,label \"Prediction\")plt.legend(prop {\"size\":8})plot_predictions()##构建模型###PyTorch模型构建要点PyTorch有四个基本模块，可以用它来创建神经网络： [torch.nn](https://pytorch.org/docs/stable/nn.html)； [torch.optim](https://pytorch.org/docs/stable/optim.html)； [torch.utils.data.Dataset](https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset)； [torch.utils.data.DataLoader](https://pytorch.org/docs/stable/data.html)；模块作用: :: :`torch.nn`包含计算图的所有构建块`torch.nn.Parameter`存储可用于`nn.Module`的张量。如果`requires_grad True`则自动计算梯度（用于通过梯度下降更新模型参数），这通常被称为“autograd”`torch.nn.Module`所有神经网络模块的基类，神经网络的所有构建块都是子类。在PyTorch中构建一个神经网络，模型应该继承`nn.Module`，需要实现`forward()`方法`torch.optim`包含各种优化算法（这些算法告诉存储在`nn.Parameter`中的模型参数。如何最好地改变，以改善梯度下降，从而减少损失)`defforward()`所有的`nn.Module`子类都需要一个`forward()`方法，定义传递给特定`nn.Module`的数据进行的计算（例如线性回归公式）简而言之： `nn.Module`包括大的构建块，如神经网络中的层； `nn.Parameter`包括小的参数，比如权重和偏置，众多参数构成`nn.Module`； `forward()`定义了在`nn.Module`中对输入的计算； `torch.optim`包含如何改进`nn.Parameter`中的参数的算法，以更好地表征数据一个简单的神经网络例子：classLinearRegressionModel(nn.Module):def__init__(self):super().__init__()self.weights nn.Parameter(torch.randn(1,dtype torch.float),requires_grad True)self.bias nn.Parameter(torch.randn(1,dtype torch.float),requires_grad True)defforward(self,x:torch.Tensor) >torch.Tensor:returnself.weights*x+self.bias###检视模型中的内容使用`model.parameters()`检查参数：torch.manual_seed(42)model_0 LinearRegressionModel()list(model_0.parameters())使用`model.state_dict()`获得模型状态（包含什么）：model_0.state_dict()###使用`torch.inference_mode()`进行预测`torch.inference_mode()`关闭了一些东西，比如梯度跟踪（训练所必需的，但不是推理所必需的），所以`forward`传递更快。withtorch.inference_mode():y_preds model_0(X_test)plot_predictions(predictions y_preds)由图可知模型预测距离真实值仍有一段距离，所以需要训练模型以达到更好的效果。##训练模型###建立损失函数和优化器为了让模型自己更新参数，需要添加损失函数和优化器。功能作用PyTorch的形式常用值: :: :: :: :损失函数测量模型的预测（`y_preds`）与真值标签（`y_test`）相比的错误程度。越低越好`torch.nn`中有很多内置的损失函数回归问题的平均绝对误差（MAE，`torch.nn.L1Loss()`）；二元分类问题的二元交叉熵（`torch.nn.BCELoss()`）优化器告诉模型如何更新其内部参数以最大程度地降低损失`torch.optim`中的各种优化函数实现随机梯度下降（`torch.optim.SGD()`）；Adam优化器（`torch.optim.Adam()`）为模型添加损失函数和优化器：###训练循环训练过程有以下步骤：序号步骤做法代码: :: :: :: :1前向传播模型将所有训练数据遍历一次，执行其`forward()`函数计算`model(x_train)`2计算损失将模型的输出（预测）与真实数据进行评估，计算损失值`loss loss_fn(y_pred,y_train)`3梯度归零优化器的梯度被设置为零（默认情况下它们是累积的），因此它们可以为特定的训练步骤重新计算`optimizer.zero_grad()`4反向传播损失计算每个要更新的模型参数的损失梯度（每个参数`requires_grad True`）`loss.backward()`5更新参数使用`requires_grad True`更新损耗梯度的参数`optimizer.step()`###测试循环测试过程有以下步骤：序号步骤做法代码: :: :: :: :1前向传播模型将所有训练数据遍历一次，执行其`forward()`函数计算`model(x_train)`2计算损失将模型的输出（预测）与真实数据进行评估，计算损失值`loss loss_fn(y_pred,y_train)`3计算评估指标（可选）计算其他评估指标，例如测试集上的准确性自定义函数###训练并测试代码torch.manual_seed(42)device \"cuda\"iftorch.cuda.is_available()else\"cpu\"X_train X_train.to(device)y_train y_train.to(device)X_test X_test.to(device)y_test y_test.to(device)model_0 model_0.to(device)epochs 200train_loss_values []test_loss_values []epoch_cnt []loss_fn nn.L1Loss()#损失函数optimizer torch.optim.SGD(params model_0.parameters(),lr 0.01)#优化器forepochinrange(epochs):model_0.train()#设置为训练模式#1.前向传播y_pred model_0(X_train)#2.计算损失loss loss_fn(y_pred,y_train)#3.梯度归零、反向传播、更新参数optimizer.zero_grad()loss.backward()optimizer.step()model_0.eval()#设置为评估模式withtorch.inference_mode():test_pred model_0(X_test)test_loss loss_fn(test_pred,y_test.type(torch.float))ifepoch%20 0:epoch_cnt.append(epoch)train_loss_values.append(loss.cpu().detach().numpy())test_loss_values.append(test_loss.cpu().detach().numpy())print(f\"{epoch}/{epochs}MAE训练损失:{loss}MAE测试损失:{test_loss}\")0/200 MAE 训练损失: 0.31288135051727295 MAE 测试损失: 0.48106518387794495 20/200 MAE 训练损失: 0.08908725529909134 MAE 测试损失: 0.21729658544063568 40/200 MAE 训练损失: 0.04543796926736832 MAE 测试损失: 0.11360953003168106 60/200 MAE 训练损失: 0.03818932920694351 MAE 测试损失: 0.08886633068323135 80/200 MAE 训练损失: 0.03132382780313492 MAE 测试损失: 0.07232122868299484 100/200 MAE 训练损失: 0.024458957836031914 MAE 测试损失: 0.05646304413676262 120/200 MAE 训练损失: 0.01758546754717827 MAE 测试损失: 0.04060482606291771 140/200 MAE 训练损失: 0.010716589167714119 MAE 测试损失: 0.024059748277068138 160/200 MAE 训练损失: 0.003851776709780097 MAE 测试损失: 0.008201557211577892 180/200 MAE 训练损失: 0.008932482451200485 MAE 测试损失: 0.005023092031478882损失随着时间的推移而下降，绘图：plt.figure(figsize (5,3))plt.plot(epoch_cnt,train_loss_values,label \"TrainLoss\")plt.plot(epoch_cnt,test_loss_values,label \"TestLoss\")plt.title(\"LossCurves\")plt.ylabel(\"Loss\")plt.xlabel(\"Epochs\")plt.legend()输出一下训练得到的`weight`和`bias`：print(model_0.state_dict())print(f\"{weight},{bias}\")OrderedDict([('weights', tensor([0.6990], device 'cuda:0')), ('bias', tensor([0.3093], device 'cuda:0'))]) 0.7, 0.3由此可知训练得到的参数与实际的参数已经相差很小了。##使用训练后的PyTorch模型进行推理在使用PyTorch模型进行预测（也称为执行推理）时，需要记住三件事：1.将模型设置为评估模式（`model.eval()`）。2.使用推理模式上下文管理器（使用`torch.inference_mode()`）进行预测。3.所有的预测都应该在同一设备上进行（仅在GPU上的数据和模型或仅在CPU上的数据和模型）。前两项确保关闭PyTorch在训练期间在幕后使用的所有有用的计算和设置，但这些计算和设置对于推理是不必要的（这导致更快的计算）。第三个确保你不会遇到跨设备错误。最后查看整体的分布：model_0.eval()withtorch.inference_mode():y_preds model_0(X_test)plot_predictions(predictions y_preds.cpu())##保存和加载模型比如在服务器上训练模型后，需要转移到本地或其他地方进行使用。方法作用: :: :`torch.save`使用Python的`pickle`实用程序将序列化的对象保存到磁盘。模型、张量和其他各种Python对象（如字典）都可以使用`torch.save`保存`torch.load`使用`pickle`的unpickling特性来反序列化并将文件（如模型，张量或字典）加载到内存中。也可以设置加载对象到哪个设备（CPU，GPU等）`torch.nn.Module.load_state_dict`使用已保存的`state_dict()`对象加载模型的参数字典（`model.state_dict()`）###保存模型的参数字典torch.save(obj model_0.state_dict(),f \"model_0.pth\")###加载参数字典到模型中loaded_model_0 LinearRegressionModel()loaded_model_0.load_state_dict(torch.load(f \"model_0.pth\",weights_only True))#测试看看预测结果是否相等loaded_model_0.to(device)loaded_model_0.eval()withtorch.inference_mode():loaded_model_preds loaded_model_0(X_test)loaded_model_preds y_preds"},"/StyleTransfer/ref-and-notes/pytorch-install.html":{"title":"PyTorch 安装","content":" title: PyTorch 安装 keywords: PyTorch desc: PyTorch 安装 date: 2025 02 07 id: pytorch Reference: [Zero to Mastery Learn PyTorch for Deep Learning](https://www.learnpytorch.io/) ## PyTorch 基本环境搭建 1. 创建并激活环境 ```bat python m venv [venv name] [venv name]\\Scripts\\activate ``` 2. 安装 Pytorch ```bat pip install torch torchvision torchaudio ``` 验证 Pytorch 安装，出现版本号则为正常。 ## PyTorch GPU 环境搭建 在搭建虚拟环境后，如果需要在 GPU 上运行，需要安装 PyTorch GPU 版本。 1. 确定自己的 GPU CUDA 版本。 ```bat nvidia smi ``` 2. 下载对应的 PyTorch GPU 版本。[官方引导下载](https://pytorch.org/get started/locally/) 附镜像页面链接： PyTorch官方镜像 [Torch](https://download.pytorch.org/whl/torch/) [TorchVision](https://download.pytorch.org/whl/torchvision/) [TorchAudio](https://download.pytorch.org/whl/torchaudio/) [阿里云镜像源](https://mirrors.aliyun.com/pytorch wheels/) 支持的 CUDA：10.0、10.1、10.2、11.0、11.1、11.3、11.5、11.6、11.7、11.8、12.1 3. 检测是否可用。 ```python import torch print(torch.cuda.is_available()) ```"},"/StyleTransfer/ref-and-notes/pytorch-tensor.html":{"title":"PyTorch 张量","content":"Reference:[ZerotoMasteryLearnPyTorchforDeepLearning](https://www.learnpytorch.io/)*该页面为JupyterNotebook生成，原文件于[Github](https://github.com/Fingsinz/StyleTransfer/tree/main/src/02.pytorch_learning/pytorch tensor.ipynb)*importtorchtorch.__version__##什么是张量张量用于表示数据，是机器学习的基本组成部分。 图片可以是三维张量，如`[height,width,channel]`，如经典的lena图片用张量表示：importnumpyasnpfromPILimportImage#使用pillow打开图片,转换为numpy矩阵,再转换为torch张量img torch.from_numpy(np.array(Image.open(\"imgs/lena.jpg\")))img.shape##创建张量Tensors说明文档：[https://pytorch.org/docs/stable/tensors.html](https://pytorch.org/docs/stable/tensors.html)1.Scalar，标量是一个单独的数字，用张量的术语来说是一个零维张量。scalar torch.tensor(3.0)#维度同样可以通过tensor.dim()获取print(f\"scalar为{scalar},维度为{scalar.ndim},常量通过item方法获取{scalar.item()}数字\")scalar为3.0, 维度为0, 常量通过item方法获取3.0数字2.Vector，向量是一个一维张量，类似于数组。vector torch.tensor([1.0,2.0,3.0])print(f\"vector为{vector},维度为{vector.ndim},通过shape属性获取形状{vector.shape}\")vector为tensor([1., 2., 3.]), 维度为1, 通过shape属性获取形状torch.Size([3])3.Matrix，矩阵是一个二维张量。matrix torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]])print(f\"{matrix},\\n维度为{matrix.ndim},通过shape属性获取形状{matrix.shape}\")tensor([[1., 2., 3.], [4., 5., 6.]]), 维度为2, 通过shape属性获取形状torch.Size([2, 3])总结：结构表示维度: :: :: :scalar一个数字0vector一组数字1matrix一个矩阵2tensor若干维度0维表示scalar，每一维表示一个vector###`torch.rand()`生成随机张量实际上在机器学习中很少会手动创建张量，更多是随机生成。#创建指定大小的随机张量random_tensor torch.rand(size (3,4))random_tensor,random_tensor.dtype###填充全零或全一张量zeros torch.zeros(size (3,4))ones torch.ones(size (3,4))zeros,zeros.dtypeones,ones.dtype###创建一个范围张量#创建一个从0到9的张量的两种方法#zero_to_ten1 torch.range(0,10)#将弃用zero_to_ten2 torch.arange(start 0,end 10,step 1)#zero_to_ten1,zero_to_ten1.dtypezero_to_ten2,zero_to_ten2.dtype#创建一个形状一样的向量same_shape torch.zeros_like(input zero_to_ten2)same_shape,same_shape.dtype##张量数据类型Tensor的DataTypes：[https://pytorch.org/docs/stable/tensors.html#data types](https://pytorch.org/docs/stable/tensors.html#data types)有些数据类型是特定于CPU，而有些更适合GPU。同时确保精度问题，可以选用不同精度的浮点数类型。float32_tensor torch.tensor([3.0,6.0,9.0],dtype None,#默认为None，即torch。Float32或传递的任何数据类型device None,#默认为None，使用默认的张量类型requires_grad False)#如果为True，则记录对张量执行的操作float32_tensor.shape,float32_tensor.dtype,float32_tensor.device可以修改张量的数据类型：float64_tensor float32_tensor.type(torch.float64)float64_tensor.dtype在进行带张量的操作时，除了张量的Shape要匹配之外，还需要注意张量的dtype和device。 `tensor.shape`：获取Shape。 `tensor.dtype`：获取dtype。 `tensor.device`：获取device。##张量的操作###张量的基础操作张量的加减乘操作如下：test_tensor torch.tensor([1,2,3])test_tensor+10,test_tensor*10,test_tensor 1,test_tensor#在不赋值的时候是不变的也可以通过函数实现：torch.add(test_tensor,10),torch.mul(test_tensor,10),torch.sub(test_tensor,1)注意，**矩阵乘法遵循其规则，与形状相关。**$$M_{m\\timesn} M_{m\\timesk}@M_{k\\timesn}$$*`@`在Python中是矩阵乘法*tensor torch.tensor([1,2,3])tensor*tensor,tensor@tensor,torch.matmul(tensor,tensor)#torch.matmul是矩阵乘法，且比@操作更快 $[1,2,3]*[1,2,3] [1*1,2*2,3*3] [1,4,9]$ $[1,2,3]@[1,2,3] 1*1+2*2+3*3 14$`torch.mm()`是`torch.matmul()`的缩写。另外提供一些操作进行矩阵变换： `torch.transpose(input,dim0,dim1)`，`input`是输入矩阵，`dim0`和`dim1`是要交换的维度。 `torch.T`：转置矩阵。###求最小值、最大值、平均值、总和等x torch.arange(0,100,10)print(x)print(f\"最小值:{x.min()}\")print(f\"最大值:{x.max()}\")#print(f\"Mean:{x.mean()}\")#会报错print(f\"均值:{x.type(torch.float32).mean()}\")#没有float数据类型将无法工作print(f\"总和:{x.sum()}\")tensor([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) 最小值: 0 最大值: 90 均值: 45.0 总和: 450*一些方法，如torch.mean()，要求张量位于torch.float32（最常见）或其他特定数据类型中，否则操作将失败。*###求最小最大值的位置print(x)print(f\"Indexwheremaxvalueoccurs:{x.argmax()}\")print(f\"Indexwhereminvalueoccurs:{x.argmin()}\")tensor([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) Index where max value occurs: 9 Index where min value occurs: 0###张量形状重塑、堆叠、挤压和扩展因为深度学习模型（神经网络）都是关于以某种方式操纵张量的。因为矩阵乘法的规则，如果有形状不匹配，就会遇到错误。这些方法帮助你确保你的张量的正确元素与其他张量的正确元素混合在一起。方法描述: :: :[torch.reshape(input,shape)](https://pytorch.org/docs/stable/generated/torch.reshape.html#torch.reshape)或`torch.Tensor.reshape()`在兼容的情况下把`input`重塑成`shape`的形状[Tensor.view(shape)](https://pytorch.org/docs/stable/generated/torch.Tensor.view.html)以不同的形状返回原始张量的视图，但与原始张量共享相同的数据[torch.stack(tensors,dim 0)](https://pytorch.org/docs/1.9.1/generated/torch.stack.html)沿着一个新的维度`dim`连接一系列张量，所有张量必须是相同的大小[torch.squeeze(input)](https://pytorch.org/docs/stable/generated/torch.squeeze.html)挤压`input`，删除值为1的所有维度[torch.unsqueeze(input,dim)](https://pytorch.org/docs/1.9.1/generated/torch.unsqueeze.html)在`dim`处添加值为1的维度并返回[torch.permute(input,dims)](https://pytorch.org/docs/stable/generated/torch.permute.html)返回原始输入的视图，其维度重新排列`tensor.reshape()`：importtorchx torch.arange(1.,9.)x_reshaped x.reshape(1,8)#重塑print(f\"x.shape:{x.shape},x_reshaped.shape:{x_reshaped.shape}\")x.shape: torch.Size([8]), x_reshaped.shape: torch.Size([1, 8])`tensor.view()`：改变视图也会改变原来的张量。x_viewed x.view(2,4)#重塑print(f\"x.shape:{x.shape},x_viewed.shape:{x_viewed.shape}\")#修改x_viewd,x同步变化x_viewed[:,0] 5print(x)print(x_viewed)x.shape: torch.Size([8]), x_viewed.shape: torch.Size([2, 4]) tensor([5., 2., 3., 4., 5., 6., 7., 8.]) tensor([[5., 2., 3., 4.], [5., 6., 7., 8.]])用该函数改变一个张量的视图实际上只会创建同一个张量的新视图。如果想要将新张量在自身之上堆叠五次，可以使用`torch.stack()`来实现。x_stacked torch.stack([x,x,x,x],dim 0)x_stacked同时可以移除单维度：print(x_reshaped.shape)x_squzzed x_reshaped.squeeze()print(x_squzzed.shape)torch.Size([1, 8]) torch.Size([8])与`torch.squeeze()`相反，可以使用`torch.unsqueeze()`在特定索引处添加一个维度值1：print(x_squzzed.shape)x_unsquzzed x_squzzed.unsqueeze(dim 0)print(x_unsquzzed.shape)torch.Size([8]) torch.Size([1, 8])`torch.permute(input,dims)`重排张量的维度：img torch.rand(size (128,256,3))img_permuted img.permute(2,0,1)img.shape,img_permuted.shape###张量取下标importtorchx torch.arange(1,10).reshape(1,3,3)print(f\"{x},{x.shape}\")print(f\"x[0]:\\n{x[0]}\")print(f\"x[0][0]:{x[0][0]}\")print(f\"x[0][0][0]:{x[0][0][0]}\")tensor([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]), torch.Size([1, 3, 3]) x[0]: tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) x[0][0]: tensor([1, 2, 3]) x[0][0][0]: 1*可以使用`:`来指定此维度中的所有值，使用逗号`,`来添加另一个维度。*##Pytorch张量和NumpyNumPy和PyTorch数据结构互转： NumpyArray >PyTorchTensor：`torch.from_numpy(ndarray)`。 PyTorchTensor >NumpyArray：`torch.Tensor.numpy()`。##Tensor随机值`torch.rand()`方法可以生成一个给定大小而值随机的张量，但是每次生成都会不一样。如果需要每次随机都一样，需要固定下随机数种子。importtorchimportrandomRANDOM_SEED 42torch.manual_seed(seed RANDOM_SEED)random_tensor_A torch.rand(3,4)torch.random.manual_seed(seed RANDOM_SEED)random_tensor_B torch.rand(3,4)print(f\"TensorA:\\n{random_tensor_A}\\n\")print(f\"TensorB:\\n{random_tensor_B}\\n\")print(f\"A B?\")print(random_tensor_A random_tensor_B)Tensor A: tensor([[0.8823, 0.9150, 0.3829, 0.9593], [0.3904, 0.6009, 0.2566, 0.7936], [0.9408, 0.1332, 0.9346, 0.5936]]) Tensor B: tensor([[0.8823, 0.9150, 0.3829, 0.9593], [0.3904, 0.6009, 0.2566, 0.7936], [0.9408, 0.1332, 0.9346, 0.5936]]) A B? tensor([[True, True, True, True], [True, True, True, True], [True, True, True, True]])##GPU下使用张量导入PyTorch：importtorchtorch.cuda.is_available()设置设备类型：#Setdevicetypedevice \"cuda\"iftorch.cuda.is_available()else\"cpu\"device检查设备数：torch.cuda.device_count()###张量在CPU和GPU间移动通过调用`to(device)`将张量（和模型）放在特定的设备上。GPU可以提供比CPU更快的数值计算，但有时候某些操作不支持在GPU中执行，所以需要将张量进行移动。张量移动到GPU侧：tensor torch.tensor([1,2,3])print(tensor,tensor.device)tensor_on_gpu tensor.to(device)print(tensor_on_gpu)tensor([1, 2, 3]) cpu tensor([1, 2, 3], device 'cuda:0')张量移动到CPU侧：通过使用`tensor.CPU()`tensor_back_on_cpu tensor_on_gpu.cpu()print(tensor_back_on_cpu)#上面的代码返回CPU内存中GPU张量的副本，原始张量仍然在GPU上。print(tensor_on_gpu)tensor([1, 2, 3]) tensor([1, 2, 3], device 'cuda:0')"},"/StyleTransfer/ref-and-notes/index.html":{"title":"参考文献及笔记","content":" title: 参考文献及笔记 keywords: desc: 参考文献阅读及其代码测试 date: 2025 01 16 1. 原始GAN: [Generative Adversarial Networks](https://arxiv.org/abs/1406.2661)"}}