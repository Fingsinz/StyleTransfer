{"/StyleTransfer/ref-and-notes/gan.html":{"title":"生成对抗网络","content":" title: 生成对抗网络 keywords: GAN desc: GAN文献及笔记 date: 2025 02 01 id: ref_GAN [Generative Adversarial Networks](https://arxiv.org/abs/1406.2661) *Goodfellow I , Pouget Abadie J , Mirza M ,et al.Generative Adversarial Nets[J].MIT Press, 2014.DOI:10.3156/JSOFT.29.5_177_2.* > We propose a new framework for estimating generative models via an adversarial process, in which we simultaneously train two models: a generative model G that captures the data distribution, and a discriminative model D that estimates the probability that a sample came from the training data rather than G. The training procedure for G is to maximize the probability of D making a mistake. This framework corresponds to a minimax two player game. In the space of arbitrary functions G and D, a unique solution exists, with G recovering the training data distribution and D equal to ½ everywhere. In the case where G and D are defined by multilayer perceptrons, the entire system can be trained with backpropagation. There is no need for any Markov chains or unrolled approximate inference networks during either training or generation of samples. Experiments demonstrate the potential of the framework through qualitative and quantitative evaluation of the generated samples. **摘要**：论文提出一个通过对抗过程估计生成模型的新框架。在对抗过程中，同时训练两个模型：一个捕获数据分布的生成器 G，和一个估计样本来自训练数据还是生成器 G 的判别器 D。生成器 G 的训练过程是最大化判别器 D 犯错的概率。这个框架相当于一个极大极小二人博弈游戏。在任意的 G 和 D 函数空间中，存在唯一解，使得生成器 G 能复刻训练集的数据分布，同时判别器 D 对于生成器 G 生成的任意样本作出的判断都是真假参半（真假概率各半）。如果生成器 G 和判别器 D 都定义为多层感知器，那么整个系统可以使用误差反向传播进行训练。在模型的训练过程以及样本的生成中，不需要使用马尔科夫链或者展开的近似推理网络。通过对生成的样本进行定性和定量评估，实验证明了该框架的潜力。 ## GAN 模型 GAN包含两个模型： 1. **生成器（Generator, G）**：将随机噪声映射到数据空间，目标是生成与真实数据分布 $p_{\\text{data}}$ 一致的样本。 2. **判别器（Discriminator, D）**：区分输入样本来自真实数据还是生成器，输出为样本真实性的概率。 两者通过**极小极大博弈**进行训练： 为了学习生成器在数据 $x$ 上的分布 $p_g$，定义输入噪声变量 $p_z(z)$ 的先验，然后将数据空间的映射表示为 $G(z; \\theta_g)$，其中 $G$ 是由具有参数 $\\theta_g$ 的多层感知器表示的可微函数。 定义第二个多层感知器 $D(x; \\theta_d)$，其输出一个标量。$D(x)$ 表示 $x$ 来自真实数据而不是 $p_g$ 的概率。 **训练判别器 D，最大化正确分类训练样本和生成器 G 生成样本的概率；同时训练生成器 G，最小化 $\\log(1−D(G(z)))$，即让生成样本 $G(z)$ 被判别器误判为真实样本（$D(G(z))→1$）**。 综上所述，GAN 的训练过程可表示为： $$ \\min_G \\max_D V(D, G) \\mathbb{E}_{x \\sim p_{\\text{data}}(x)} [\\log D(x)] + \\mathbb{E}_{z \\sim p_z(z)} [\\log(1 D(G(z)))]\\tag{1} $$ 当生成器 G 分布 $p_g p_{data}$，判别器 D 的最优解为 $D^*(x) \\frac{1}{2}$ 时，目标函数达到最小值 $\\log({\\frac{1}{2}}) + \\log(1 \\frac{1}{2}) \\log{4}$。 ## 网络理论 ### 算法步骤 *小批量随机梯度下降，$k$ 为超参数。* ``` for i 1, iterations do for k steps do m 个噪声样本的小批量样本 {z(1),., z(m)}，来自噪声先验 pg(z)。 m 个真实样本的小批量样本 {x(1),., x(m)}，来自真实数据集。 通过公式 2 提升判别器随机梯度来更新判别器。 end for m 个噪声样本的小批量样本 {z(1),., z(m)}，来自噪声先验 pg(z)。 通过公式 3 降低生成器随机梯度来更新生成器。 end for ``` $$ \\nabla_{\\theta_d} \\frac{1}{m} \\sum_{i 1}^m \\left[\\log D(x^{(i)}) + \\log(1 D(G(z^{(i)}))) \\right] \\tag{2} $$ $$ \\nabla_{\\theta_g} \\frac{1}{m} \\sum_{i 1}^m \\log\\left(1 D(G(z^{(i)}))\\right) \\tag{3} $$ 训练过程的巧思： 1. **在 $k$ 步优化判别器 D 和 $1$ 步优化生成器 G 之间交替进行**：在 one step 的内部循环中优化判别器 D 在计算上是不可行的，并且容易在有限的数据集上导致过拟合。 2. **最大化 $\\log D(G(z))$ 代替最小化 $\\log(1−D(G(z)))$ 训练生成器 G**：在生成器 G 效果很差时，判别器 D可以以高置信度拒绝样本，这种情况下，$\\log(1−D(G(z)))$ 不起作用。 原文中提供下图： ![](../static/images/GAN/fig1.png) *注：黑色散点线为真实数据的分布；绿色实线为生成器 $G$ 生成数据的分布；蓝色虚线为判别器 $D$ 的分布，区分黑色散点与绿色实线。最下面的直线为均匀采样 $z$ 的域；其上面的直线是 $x$ 域的一部分。向上的箭头表示 $x G(z)$ 的映射关系。* 图 (a)：对抗接近收敛，$p_g$ 接近 $p_{data}$，判别器部分分类正确（能否分辨出真实数据和生成数据）。 图 (b)：在算法的内部循环中，判别器 D 向着分类数据训练，收敛在 $D^*(x) \\frac {p_{data}(x)}{p_{data}(x) + p_g(x)}$。 图 (c)：更新生成器 $G$ 后，判别器 $D$ 的梯度引导 $G(z)$ 偏向更有可能被归类为真实数据的区域。 图 (d)：经过若干步训练后，如果 $G$ 和 $D$ 有足够的容量，它们会收敛到 $p_g p_{data}$，此时 $D$ 无法区分出真实数据和生成数据，即 $D(x) \\frac {1}{2}$。 ### 解释全局最优解 $p_g p_{data}$ **命题 1.** 对于固定的生成器 $G$，最优判别器 $D$ 为： $$ D^*_G(x) \\frac {p_{data}(x)}{p_{data}(x) + p_g(x)} $$ **证明：** 给定任何生成器 $G$ 的判别器 $D$ 的训练标准是最大化 $V(G, D)$。 $$ V(G,D) \\int_x p_{data}(x) \\log(D(x))dx + \\int_z p_z(z) \\log(1 D(g(z)))dz\\tag{4} $$ 通过变量替换 $G(z) x \\sim p_g(x)$，式(4)改写为： $$ V(G,D) \\int_x \\left[p_{data}(x) \\log(D(x)) + p_g(x) \\log(1 D(x))\\right] dx $$ > *生成器 $G$ 将噪声输入 $z \\sim p_z(z)$ 映射为样本 $x G(z)$，隐式定义了生成样本的分布 $p_g(x)$。当 $z$ 服从噪声先验 $p_z(z)$ 分布时，$x G(z)$ 的分布即为 $p_g(x)$；若 $z \\sim p_z(z)$，则 $x G(z)\\sim p_g(x)$。* > *对于变量替换定理，对于任意函数 $h(x)$，若 $x$ 是随机变量 $z$ 的映射 $x G(z)$，则关于 $z$ 的期望可以转换为关于 $x$ 的期望：$\\mathbb{E}_{z \\sim p_z(z)}[h(G(z))] \\mathbb{E}_{x \\sim p_g(x)}[h(x)]$。* 对于每个样本 $x$，求 $D(x)$ 使得 $V(D,G)$ 最大化。这是一个单变量优化问题，最优解为： $$ D^*_G(x) \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} $$ 将最优判别器代入到目标函数有： $$ \\begin{aligned} C(G) & \\max_D V(G,D)\\\\ & \\mathbb{E}_{x \\sim p_{\\text{data}}} \\left[\\log D^*_G(x) \\right] + \\mathbb{E}_{z \\sim p_z} \\left[\\log(1 D^*_G(G(z))) \\right] \\\\ & \\mathbb{E}_{x \\sim p_{\\text{data}}} \\left[\\log D^*_G(x) \\right] + \\mathbb{E}_{x \\sim p_g} \\left[\\log(1 D^*_G(x)) \\right]\\\\ & \\mathbb{E}_{x \\sim p_{\\text{data}}} \\left[\\log \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} \\right] + \\mathbb{E}_{x \\sim p_g} \\left[\\log \\frac {p_{g}(x)}{p_{data}(x) + p_{g}(x)} \\right] \\end{aligned}\\tag{5} $$ **定理 1.** 当且仅当 $p_g p_{data}$ 时，$C(G)$ 达到的全局最小值 $ \\log 4$。 **证明：** 对于 $p_g p_{data}$，有 $D^*_G(x) \\frac{1}{2}$。因此： $$ C(G) \\mathbb{E}_{x\\sim p_{data}} \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} + \\mathbb{E}_{x\\sim p_{g}} \\frac {p_{g}(x)}{p_{data}(x) + p_{g}(x)} \\log \\frac {1}{2} + \\log \\frac {1}{2} \\log 4 $$ GAN 的优化目标是最小化生成模型分布 $p_g$ 和真实数据分布 $p_{data}$ 之间的差异，将目标函数中的对数概率表达为 KL 散度的形式。引入变形以关联 KL 散度： $$ \\begin{aligned} \\log \\frac {p_{data}(x)}{p_{data}(x) + p_{g}(x)} \\log \\frac {p_{data}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\log 2 \\\\ \\log \\frac {p_{g}(x)}{p_{data}(x) + p_{g}(x)} \\log \\frac {p_{g}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\log 2 \\end{aligned} $$ 所以， $$ \\begin{aligned} C(G) & \\log 4 + \\mathbb{E}_{x\\sim p_{data}} \\left[\\log \\frac {p_{data}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\right] + \\mathbb{E}_{x\\sim p_{g}} \\left[\\log \\frac {p_{g}(x)}{\\frac {p_{data}(x)+p_g(x)}{2}} \\right] \\\\ & \\log 4 + \\text{KL}\\left(p_{data}\\frac{p_{data}+p_g}{2}\\right) + \\text{KL}\\left(p_g\\frac{p_{data}+p_g}{2}\\right) \\\\ & \\log 4 + 2 \\cdot \\text{JSD}(p_{data} p_g) \\end{aligned} $$ >其中，KL 散度是衡量两个分布差异的常见方法，定义为：$\\text{KL}(pq) \\mathbb{E}_{x\\sim p} \\log \\frac {p(x)}{q(x)}$。Jensen Shannon 散度（JSD）是 KL 散度的一个对称版本，是衡量两个分布差异的对称性指标，定义为：$\\text{JSD}(pq) \\frac {1}{2} \\text{KL}(p \\frac {p + q}{2}) + \\frac {1}{2} \\text{KL}(q \\frac {p + q}{2})$。 由于 JSD 非负，当且仅当 $p q$ 时为零，因此： $$ C(G) \\geq \\log 4, 且等号成立当且仅当 p_g p_{data} $$ 证毕。 ### 解释算法收敛性 **命题 2.** 如果生成器 $G$ 和判别器 $D$ 都有足够的容量，并且算法的每一步都允许判别器在给定 $G$ 的情况下达到最优，并更新 $p_g$ 以改进标准 $\\mathbb{E}_{x\\sim p_{data}}[\\log D^*_G(x)] + \\mathbb{E}_{x\\sim p_{g}}[\\log (1 D^*_G(x))]$，则 $p_g$ 收敛到 $p_{data}$。 **证明：** 考虑 $V(G, D) U(p_g, D)$ 作为 $p_g$ 的函数。$U(p_g, D)$ 是凸函数，且全局最优解唯一。通过梯度下降更新 $p_g$，其参数更新方向始终朝向 JSD 减小的方向，从而保证收敛。 ## 代码实验 实验代码如下，详细代码位于[Github](https://github.com/Fingsinz/StyleTransfer/blob/main/src/01.ref_and_note/01.GAN.py)： <details> <summary>GAN MNIST 实验代码</summary> ```python ''' Created on 2025.02.01 @Author: Fingsinz (fingsinz@foxmail.com) @Reference: 1. https://arxiv.org/abs/1406.2661 ''' import time import os import torch import numpy as np import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader from torchvision import datasets, transforms import matplotlib.pyplot as plt # 配置参数 class Config(): data_folder: str './data' # 数据集路径, 此处用 MNIST 做测试 batch_size: int 128 # batch 大小 epochs: int 10 # 训练轮数 lr: float 0.0002 # 学习率 betas: tuple (0.5, 0.999) # Adam 的超参数 k_steps: int 5 # k 值 latent_dim: int 100 # 隐变量维度 device: str 'cuda' if torch.cuda.is_available() else 'cpu' # 生成器 class Generator(nn.Module): def __init__(self, latent_dim): super().__init__() self.model nn.Sequential( nn.Linear(latent_dim, 256), nn.LeakyReLU(0.2), nn.Linear(256, 512), nn.LeakyReLU(0.2), nn.Linear(512, 1024), nn.LeakyReLU(0.2), nn.Linear(1024, 28 * 28), nn.Tanh() ) def forward(self, x): return self.model(x).view( 1, 1, 28, 28) # 判别器 class Discriminator(nn.Module): def __init__(self): super().__init__() self.model nn.Sequential( nn.Flatten(), nn.Linear(28 * 28, 1024), nn.LeakyReLU(0.2, inplace True), nn.Linear(1024, 512), nn.LeakyReLU(0.2, inplace True), nn.Linear(512, 256), nn.LeakyReLU(0.2, inplace True), nn.Linear(256, 1), nn.Sigmoid() ) def forward(self, x): return self.model(x) # GAN 模型 class GAN(): def __init__(self, config): self.config config self.generator Generator(config.latent_dim).to(config.device) self.discriminator Discriminator().to(config.device) self.criterion nn.BCELoss() self.g_optimizer optim.Adam(self.generator.parameters(), lr config.lr, betas config.betas) self.d_optimizer optim.Adam(self.discriminator.parameters(), lr config.lr, betas config.betas) self.real_label 1 self.fake_label 0 def get_data(self): transform transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,)) ]) train_dataset datasets.MNIST(root self.config.data_folder, train True, download True, transform transform) train_loader DataLoader(train_dataset, batch_size self.config.batch_size, shuffle True) return train_loader def train(self): train_loader self.get_data() epochs self.config.epochs g_loss 0 d_real_loss 0 d_fake_loss 0 for epoch in range(epochs): for i, (images, _) in enumerate(train_loader): batch_size images.size(0) images images.to(self.config.device) # 判别器训练 if (i + 1) % self.config.k_steps ! 0: self.d_optimizer.zero_grad() # 训练真实数据 labels torch.full((batch_size,), self.real_label, device self.config.device).float() output self.discriminator(images) loss_real self.criterion(output.view( 1), labels) loss_real.backward() # 训练假数据 z torch.randn(batch_size, self.config.latent_dim, device self.config.device) fake_images self.generator(z) labels.fill_(self.fake_label).float() output self.discriminator(fake_images.detach()) loss_fake self.criterion(output.view( 1), labels) loss_fake.backward() self.d_optimizer.step() d_real_loss loss_real.item() d_fake_loss loss_fake.item() # 判别器训练 # 生成器训练 else: self.g_optimizer.zero_grad() labels.fill_(self.real_label).float() output self.discriminator(fake_images) loss_g self.criterion(output.view( 1), labels) loss_g.backward() self.g_optimizer.step() g_loss loss_g.item() # 生成器训练 if i % 100 0: print(f\"[{time.strftime('%Y %m %d %H:%M:%S', time.localtime())}] \" + f\"Epoch [{epoch}/{epochs}], Step [{i}/{len(train_loader)}], \" f\"D Loss: {d_real_loss:.4f} + {d_fake_loss:.4f}, G Loss: {g_loss:.4f}\") self.save_generated_images(epoch + 1) def save_generated_images(self, epoch): \"\"\" 保存训练效果图片 参数: epoch (int): 当前轮数 \"\"\" z torch.randn(64, self.config.latent_dim, device self.config.device) fake_images self.generator(z) fake_images fake_images.cpu().detach().numpy() fake_images np.transpose(fake_images, (0, 2, 3, 1)) fig, axes plt.subplots(8, 8, figsize (8, 8)) for i in range(8): for j in range(8): axes[i, j].imshow(fake_images[i * 8 + j, :, :, 0], cmap 'gray') axes[i, j].axis('off') if not os.path.exists('gan_generated_images'): os.makedirs('gan_generated_images') plt.savefig(f'./gan_generated_images/epoch_{epoch}.png') plt.close() if __name__ '__main__': config Config() gan GAN(config) gan.train() ``` </details> GAN 对于 MNIST 数据集效果可如下所示： <table> <th>第一轮生成的图片</th> <th>第十轮生成的图片</th> <tr> <td><img src \"../static/images/GAN/epoch_1.png\"></td> <td><img src \"../static/images/GAN/epoch_10.png\"></td> </tr> </table> ## 论文优缺点及未来工作 优点（DeepSeek总结）： 生成样本质量高：GAN生成的图像、音频等数据具有极高的逼真度，尤其在图像生成任务中表现出色（如人脸、艺术作品生成）。生成器通过对抗训练不断优化，以欺骗判别器，最终生成的样本细节丰富、接近真实数据分布。 无需显式建模数据分布：GAN通过对抗过程直接学习数据分布，无需预先定义概率密度函数（如VAE需要假设潜在变量的分布），适用于复杂高维数据（如自然图像）。 生成多样性：在理想情况下，GAN能够覆盖真实数据的所有模式，生成多样化样本。相比之下，某些模型（如朴素自回归模型）可能因逐像素生成导致模式单一化。 无监督学习能力：GAN仅需未标注数据即可训练，适合缺乏标签的场景（如艺术创作、数据增强）。 灵活的应用扩展：GAN框架可轻松扩展为条件生成（cGAN）、图像翻译（CycleGAN）、超分辨率（SRGAN）等任务，适应多种生成需求。 缺点（DeepSeek总结）： 训练不稳定 模式坍缩（Mode Collapse）：生成器可能仅生成少数几种样本，忽略数据多样性。 梯度问题：若判别器过强，生成器梯度消失；若生成器过强，判别器无法提供有效反馈。 评估困难 缺乏显式似然函数，难以直接计算生成样本的概率。 常用指标（如Inception Score、FID）依赖预训练模型，可能无法全面反映生成质量。 超参数敏感：学习率、网络结构、正则化方法等对训练结果影响显著，需反复调参。 理论分析复杂 收敛性难以保证，实际训练可能陷入局部最优。 均衡状态（纳什均衡）在有限模型容量下难以达到。 生成不可控性 生成过程缺乏显式约束，可能产生不合理样本（如人脸扭曲）。 对离散数据（如文本）生成效果较差，因梯度无法通过离散变量传递。 计算资源消耗大：训练高质量GAN需要大量数据和计算资源（如GPU），耗时较长。 未来工作： 更好地理解这种框架，例如在高维空间中的表现； 探索其他算法和数据结构，例如使用卷积神经网络作为掩码器； 探索其他训练方法，例如使用梯度反向传递训练模型； 探索其他损失函数，例如使用KL损失函数； 探索其他训练方法，例如使用GAN训练模型。"},"/StyleTransfer/ref-and-notes/pytorch-basic-workflow.html":{"title":"PyTorch 基本工作流","content":"Reference:[PyTorchWorkflowFundamentals](https://www.learnpytorch.io/01_pytorch_workflow/)*该页面为JupyterNotebook生成，原文件于[Github](https://github.com/Fingsinz/StyleTransfer/tree/main/src/02.pytorch_learning/pytorch basic workflow.ipynb)*#先导入包importtorchfromtorchimportnnimportmatplotlib.pyplotasplttorch.__version__##准备数据集数据可以是很多东西，如一个表格、任何类型的图像、视频、歌曲或播客等音频文件，蛋白质结构，文本等等。机器学习是一个由两部分组成：1.把你的数据转换成数字表示。2.选择或构建一个模型来尽可能地学习数据的表征。获得数据之后，需要将数据划分为训练集、验证集和测试集。类型目的占比使用情况: :: :: :: :训练集模型从这些数据里面学习（比如学习的课程材料）\\~60\\~80%必须有验证集模型会根据这些数据进行调整（比如期末考试前的练习）\\~10\\~20%不必有测试集模型根据这些数据进行评估，以测试它学到了什么（比如期末考试）\\~10\\~20%必须有#创建一个y weight*x+bias的数据集weight 0.7bias 0.3X torch.arange(0,1,0.02).unsqueeze(dim 1)y weight*X+bias#划分训练集和测试集train_split int(0.8*len(X))X_train,y_train X[:train_split],y[:train_split]X_test,y_test X[train_split:],y[train_split:]defplot_predictions(train_data X_train,train_labels y_train,test_data X_test,test_labels y_test,predictions None):plt.figure(figsize (5,3))plt.scatter(train_data,train_labels,c \"b\",s 4,label \"Trainingdata\")plt.scatter(test_data,test_labels,c \"g\",s 4,label \"Testingdata\")ifpredictionsisnotNone:plt.scatter(test_data,predictions,c \"r\",s 4,label \"Prediction\")plt.legend(prop {\"size\":8})plot_predictions()##构建模型###PyTorch模型构建要点PyTorch有四个基本模块，可以用它来创建神经网络： [torch.nn](https://pytorch.org/docs/stable/nn.html)； [torch.optim](https://pytorch.org/docs/stable/optim.html)； [torch.utils.data.Dataset](https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset)； [torch.utils.data.DataLoader](https://pytorch.org/docs/stable/data.html)；模块作用: :: :`torch.nn`包含计算图的所有构建块`torch.nn.Parameter`存储可用于`nn.Module`的张量。如果`requires_grad True`则自动计算梯度（用于通过梯度下降更新模型参数），这通常被称为“autograd”`torch.nn.Module`所有神经网络模块的基类，神经网络的所有构建块都是子类。在PyTorch中构建一个神经网络，模型应该继承`nn.Module`，需要实现`forward()`方法`torch.optim`包含各种优化算法（这些算法告诉存储在`nn.Parameter`中的模型参数。如何最好地改变，以改善梯度下降，从而减少损失)`defforward()`所有的`nn.Module`子类都需要一个`forward()`方法，定义传递给特定`nn.Module`的数据进行的计算（例如线性回归公式）简而言之： `nn.Module`包括大的构建块，如神经网络中的层； `nn.Parameter`包括小的参数，比如权重和偏置，众多参数构成`nn.Module`； `forward()`定义了在`nn.Module`中对输入的计算； `torch.optim`包含如何改进`nn.Parameter`中的参数的算法，以更好地表征数据一个简单的神经网络例子：classLinearRegressionModel(nn.Module):def__init__(self):super().__init__()self.weights nn.Parameter(torch.randn(1,dtype torch.float),requires_grad True)self.bias nn.Parameter(torch.randn(1,dtype torch.float),requires_grad True)defforward(self,x:torch.Tensor) >torch.Tensor:returnself.weights*x+self.bias###检视模型中的内容使用`model.parameters()`检查参数：torch.manual_seed(42)model_0 LinearRegressionModel()list(model_0.parameters())使用`model.state_dict()`获得模型状态（包含什么）：model_0.state_dict()###使用`torch.inference_mode()`进行预测`torch.inference_mode()`关闭了一些东西，比如梯度跟踪（训练所必需的，但不是推理所必需的），所以`forward`传递更快。withtorch.inference_mode():y_preds model_0(X_test)plot_predictions(predictions y_preds)由图可知模型预测距离真实值仍有一段距离，所以需要训练模型以达到更好的效果。##训练模型###建立损失函数和优化器为了让模型自己更新参数，需要添加损失函数和优化器。功能作用PyTorch的形式常用值: :: :: :: :损失函数测量模型的预测（`y_preds`）与真值标签（`y_test`）相比的错误程度。越低越好`torch.nn`中有很多内置的损失函数回归问题的平均绝对误差（MAE，`torch.nn.L1Loss()`）；二元分类问题的二元交叉熵（`torch.nn.BCELoss()`）优化器告诉模型如何更新其内部参数以最大程度地降低损失`torch.optim`中的各种优化函数实现随机梯度下降（`torch.optim.SGD()`）；Adam优化器（`torch.optim.Adam()`）为模型添加损失函数和优化器：###训练循环训练过程有以下步骤：序号步骤做法代码: :: :: :: :1前向传播模型将所有训练数据遍历一次，执行其`forward()`函数计算`model(x_train)`2计算损失将模型的输出（预测）与真实数据进行评估，计算损失值`loss loss_fn(y_pred,y_train)`3梯度归零优化器的梯度被设置为零（默认情况下它们是累积的），因此它们可以为特定的训练步骤重新计算`optimizer.zero_grad()`4反向传播损失计算每个要更新的模型参数的损失梯度（每个参数`requires_grad True`）`loss.backward()`5更新参数使用`requires_grad True`更新损耗梯度的参数`optimizer.step()`###测试循环测试过程有以下步骤：序号步骤做法代码: :: :: :: :1前向传播模型将所有训练数据遍历一次，执行其`forward()`函数计算`model(x_train)`2计算损失将模型的输出（预测）与真实数据进行评估，计算损失值`loss loss_fn(y_pred,y_train)`3计算评估指标（可选）计算其他评估指标，例如测试集上的准确性自定义函数###训练并测试代码torch.manual_seed(42)device \"cuda\"iftorch.cuda.is_available()else\"cpu\"X_train X_train.to(device)y_train y_train.to(device)X_test X_test.to(device)y_test y_test.to(device)model_0 model_0.to(device)epochs 200train_loss_values []test_loss_values []epoch_cnt []loss_fn nn.L1Loss()#损失函数optimizer torch.optim.SGD(params model_0.parameters(),lr 0.01)#优化器forepochinrange(epochs):model_0.train()#设置为训练模式#1.前向传播y_pred model_0(X_train)#2.计算损失loss loss_fn(y_pred,y_train)#3.梯度归零、反向传播、更新参数optimizer.zero_grad()loss.backward()optimizer.step()model_0.eval()#设置为评估模式withtorch.inference_mode():test_pred model_0(X_test)test_loss loss_fn(test_pred,y_test.type(torch.float))ifepoch%20 0:epoch_cnt.append(epoch)train_loss_values.append(loss.cpu().detach().numpy())test_loss_values.append(test_loss.cpu().detach().numpy())print(f\"{epoch}/{epochs}MAE训练损失:{loss}MAE测试损失:{test_loss}\")0/200 MAE 训练损失: 0.31288135051727295 MAE 测试损失: 0.48106518387794495 20/200 MAE 训练损失: 0.08908725529909134 MAE 测试损失: 0.21729658544063568 40/200 MAE 训练损失: 0.04543796926736832 MAE 测试损失: 0.11360953003168106 60/200 MAE 训练损失: 0.03818932920694351 MAE 测试损失: 0.08886633068323135 80/200 MAE 训练损失: 0.03132382780313492 MAE 测试损失: 0.07232122868299484 100/200 MAE 训练损失: 0.024458957836031914 MAE 测试损失: 0.05646304413676262 120/200 MAE 训练损失: 0.01758546754717827 MAE 测试损失: 0.04060482606291771 140/200 MAE 训练损失: 0.010716589167714119 MAE 测试损失: 0.024059748277068138 160/200 MAE 训练损失: 0.003851776709780097 MAE 测试损失: 0.008201557211577892 180/200 MAE 训练损失: 0.008932482451200485 MAE 测试损失: 0.005023092031478882损失随着时间的推移而下降，绘图：plt.figure(figsize (5,3))plt.plot(epoch_cnt,train_loss_values,label \"TrainLoss\")plt.plot(epoch_cnt,test_loss_values,label \"TestLoss\")plt.title(\"LossCurves\")plt.ylabel(\"Loss\")plt.xlabel(\"Epochs\")plt.legend()输出一下训练得到的`weight`和`bias`：print(model_0.state_dict())print(f\"{weight},{bias}\")OrderedDict([('weights', tensor([0.6990], device 'cuda:0')), ('bias', tensor([0.3093], device 'cuda:0'))]) 0.7, 0.3由此可知训练得到的参数与实际的参数已经相差很小了。##使用训练后的PyTorch模型进行推理在使用PyTorch模型进行预测（也称为执行推理）时，需要记住三件事：1.将模型设置为评估模式（`model.eval()`）。2.使用推理模式上下文管理器（使用`torch.inference_mode()`）进行预测。3.所有的预测都应该在同一设备上进行（仅在GPU上的数据和模型或仅在CPU上的数据和模型）。前两项确保关闭PyTorch在训练期间在幕后使用的所有有用的计算和设置，但这些计算和设置对于推理是不必要的（这导致更快的计算）。第三个确保你不会遇到跨设备错误。最后查看整体的分布：model_0.eval()withtorch.inference_mode():y_preds model_0(X_test)plot_predictions(predictions y_preds.cpu())##保存和加载模型比如在服务器上训练模型后，需要转移到本地或其他地方进行使用。方法作用: :: :`torch.save`使用Python的`pickle`实用程序将序列化的对象保存到磁盘。模型、张量和其他各种Python对象（如字典）都可以使用`torch.save`保存`torch.load`使用`pickle`的unpickling特性来反序列化并将文件（如模型，张量或字典）加载到内存中。也可以设置加载对象到哪个设备（CPU，GPU等）`torch.nn.Module.load_state_dict`使用已保存的`state_dict()`对象加载模型的参数字典（`model.state_dict()`）###保存模型的参数字典torch.save(obj model_0.state_dict(),f \"model_0.pth\")###加载参数字典到模型中loaded_model_0 LinearRegressionModel()loaded_model_0.load_state_dict(torch.load(f \"model_0.pth\",weights_only True))#测试看看预测结果是否相等loaded_model_0.to(device)loaded_model_0.eval()withtorch.inference_mode():loaded_model_preds loaded_model_0(X_test)loaded_model_preds y_preds"},"/StyleTransfer/ref-and-notes/pytorch-classification.html":{"title":"PyTorch 神经网络分类","content":"Reference:[PyTorchNeuralNetworkClassification](https://www.learnpytorch.io/02_pytorch_classification/)*该页面为JupyterNotebook生成，原文件于[Github](https://github.com/Fingsinz/StyleTransfer/tree/main/src/02.pytorch_learning/pytorch classification.ipynb)*#先导入包importtorchfromtorchimportnnimportmatplotlib.pyplotasplttorch.__version__分类问题有二分类、多分类、多标签等情况。二分类问题则是或不是；多分类问题具有多个类别区分；多标签问题则一个目标可以被分配多个选项。##分类神经网络的结构分类神经网络的一般架构：项目二分类多分类: :: :: :输入层Shape（`in_features`）与特征数相同与特征数相同隐藏层特定问题特定分析特定问题特定分析每个隐藏层的神经元数量特定问题特定分析，一般从10到512特定问题特定分析，一般从10到512输出层Shape（`out_features`）1（一个类别）每个类1个输出隐藏层激活函数通常是ReLU通常是ReLU输出层激活函数Sigmoid（`torch.sigmoid`）Softmax（`torch.softmax`）损失函数二元交叉熵（`torch.nn.BCELoss`）交叉熵（`torch.nn.CrossEntropyLoss`）优化器SGD，AdamSGD，Adam##准备二分类数据集###输入和输出形状使用Scikit Learn中的`make_circles()`方法生成两个带有不同颜色圆点的圆。*需要安装Scikit Learn：`pipinstallscikit learn`*fromsklearn.datasetsimportmake_circlesn_samples 1000X,y make_circles(n_samples,noise 0.03,random_state 42)plt.scatter(x X[:,0],y X[:,1],c y,cmap plt.cm.RdYlBu)看看输入Shape和输出Shape，然后弄清楚输入层Shape（特征数）和输出层Shape。X.shape,y.shape#输入Shape和输出ShapeX[0].shape,y[0].shape#输入层Shape和输出层Shape这说明X的一个样本有两个特征（向量），而对应的y只有一个特征（标量）。 有两个输入对应一个输出。###划分数据集具体来说：1.将数据转换为张量。2.将数据分成训练集和测试集。X torch.from_numpy(X).type(torch.float)y torch.from_numpy(y).type(torch.float)X.dtype,y.dtype使用Scikit Learn中的函数`train_test_split()`。`test_size 0.2`（80%训练，20%测试），因为分割是随机发生的，所以使用`random_state 42`，使得随机可复现。fromsklearn.model_selectionimporttrain_test_splitX_train,X_test,y_train,y_test train_test_split(X,y,test_size 0.2,random_state 42)len(X_train),len(y_train),len(X_test),len(y_test)##构建分类模型构建模型的步骤：1.设置与设备相关的代码。2.通过继承`nn.module`来构造一个模型。3.定义损失函数和优化器。4.创建一个训练循环。###设置设备#1.设置设备device \"cuda\"iftorch.cuda.is_available()else\"cpu\"device###构建模型对象模型类的操作：1.继承`nn.Module`。2.在构造函数中创建2层`nn.Linear`线性层，能够处理X和y的形状。3.定义一个`forward()`方法，该方法包含模型的前向传递计算。4.实例化模型类并将其发送到目标设备。classCircleModelV0(nn.Module):def__init__(self):super().__init__()self.layer_1 nn.Linear(in_features 2,out_features 5)self.layer_2 nn.Linear(in_features 5,out_features 1)defforward(self,x):returnself.layer_2(self.layer_1)model_0 CircleModelV0().to(device)model_0由上面代码可知该模型类的结构为：`2(输入层) >5(隐藏层) >1(输出层)`也可以使用`nn.Sequential`执行与上面相同的操作。`nn.Sequential`按层出现的顺序对输入数据执行前向传递计算。model_0 nn.Sequential(nn.Linear(in_features 2,out_features 5),nn.Linear(in_features 5,out_features 1)).to(device)model_0自定义模型类可以自定义更多细节，而`nn.Sequential()`则更方便。###定义损失函数和优化器常见损失函数：损失函数适用类型代码: :: :: :交叉熵损失函数多分类`torch.nn.CrossEntropyLoss`平均绝对误差MAE，L1Loss回归问题`torch.nn.L1Loss`均方误差MSE，L2Loss回归问题`torch.nn.MSELoss`常见优化器：优化器适用类型代码: :: :: :随机梯度下降（SGD）分类问题、回归问题等`torch.optim.SGD()`Adam分类问题、回归问题等`torch.optim.Adam()`此处讨论二分类问题，使用一个二元交叉熵损失函数。>注意：损失函数是衡量模型预测错误程度的函数，损失越高，模型越差。>>此外，PyTorch文档经常将损失函数称为“损失准则（losscriterion）”或“准则（criterion）”，这些都是描述同一事物的不同方式。二元交叉熵函数有`torch.nn.BCELoss()`和`torch.nn.BCEWithLogitsLoss()`。 `torch.nn.BCELoss()`：创建一个损失函数，用于测量目标（标签）和输入（特征）之间的二进制交叉熵。 `torch.nn.BCEWithLogitsLoss()`：它内置了一个sigmoid层，其他这与上面的相同。`torch.nn.BCEWithLogitsLoss()`的文档指出，它比在`nn.Sigmoid`层之后使用`torch.nn.BCELoss()`在数值上更稳定。对于优化器，将使用`torch.optim.SGD()`以0.1的学习率优化模型参数。loss_fn nn.BCEWithLogitsLoss()optimizer torch.optim.SGD(params model_0.parameters(),lr 0.1)评估指标可用于提供关于模型运行情况的另一个视角。如果一个损失函数衡量模型的错误程度，那么也有评估指标衡量他的正确程度。defaccuracy_fn(y_true,y_pred):correct torch.eq(y_true,y_pred).sum().item()acc (correct/len(y_pred))*100returnacc##训练分类模型###将原始输出变成标签线性层的公式为：$$y x\\cdot\\text{Weights}^T+bias$$模型的原始输出通常被称为logits。使用激活函数将logits转换成与真值标签相比较的数字。###构建训练和测试循环torch.manual_seed(42)epochs 100X_train,y_train X_train.to(device),y_train.to(device)X_test,y_test X_test.to(device),y_test.to(device)model_0 model_0.to(device)forepochinrange(epochs):model_0.train()y_logits model_0(X_train).squeeze()y_pred torch.round(torch.sigmoid(y_logits))loss loss_fn(y_logits,y_train)acc accuracy_fn(y_true y_train,y_pred y_pred)optimizer.zero_grad()loss.backward()optimizer.step()model_0.eval()withtorch.inference_mode():test_logits model_0(X_test).squeeze()test_pred torch.round(torch.sigmoid(test_logits))test_loss loss_fn(test_logits,y_test)test_acc accuracy_fn(y_true y_test,y_pred test_pred)ifepoch%10 0:print(f\"{epoch}/{epochs}Loss:{loss:.5f},Accu:{acc:.2f}%TestLoss:{test_loss:.5f},TestAccu:{test_acc:.2f}%\")0/100 Loss: 0.70365, Accu: 49.88% Test Loss: 0.71542, Test Accu: 45.50% 10/100 Loss: 0.70059, Accu: 50.25% Test Loss: 0.71142, Test Accu: 45.00% 20/100 Loss: 0.69869, Accu: 50.38% Test Loss: 0.70858, Test Accu: 46.00% 30/100 Loss: 0.69740, Accu: 50.75% Test Loss: 0.70641, Test Accu: 46.00% 40/100 Loss: 0.69648, Accu: 50.75% Test Loss: 0.70469, Test Accu: 45.50% 50/100 Loss: 0.69580, Accu: 50.50% Test Loss: 0.70329, Test Accu: 46.50% 60/100 Loss: 0.69527, Accu: 50.75% Test Loss: 0.70214, Test Accu: 46.00% 70/100 Loss: 0.69487, Accu: 50.88% Test Loss: 0.70117, Test Accu: 45.50% 80/100 Loss: 0.69455, Accu: 50.75% Test Loss: 0.70036, Test Accu: 45.00% 90/100 Loss: 0.69429, Accu: 50.75% Test Loss: 0.69966, Test Accu: 45.00%模型看起来它很好地完成了训练和测试步骤，但结果似乎并没有太大的变化。每次数据分割时，准确率在50%左右。这是一个平衡的二进制分类问题，这意味着模型的性能与随机猜测差不多。##预测评估分类模型从指标来看，模型似乎是随机猜测。绘制一个模型预测的图，它试图预测的数据以及它为某个东西是类0还是类1创建的决策边界。为此，编写一些代码，一个名为`plot_decision_boundary()`的有用函数，该函数创建一个NumPymeshgrid，以可视化地绘制我们的模型预测某些类的不同点。importnumpyasnpdefplot_decision_boundary(model:torch.nn.Module,X:torch.Tensor,y:torch.Tensor):\"\"\"PlotsdecisionboundariesofmodelpredictingonXincomparisontoy.Source https://madewithml.com/courses/foundations/neural networks/(withmodifications)\"\"\"#PuteverythingtoCPU(worksbetterwithNumPy+Matplotlib)model.to(\"cpu\")X,y X.to(\"cpu\"),y.to(\"cpu\")#Setuppredictionboundariesandgridx_min,x_max X[:,0].min() 0.1,X[:,0].max()+0.1y_min,y_max X[:,1].min() 0.1,X[:,1].max()+0.1xx,yy np.meshgrid(np.linspace(x_min,x_max,101),np.linspace(y_min,y_max,101))#MakefeaturesX_to_pred_on torch.from_numpy(np.column_stack((xx.ravel(),yy.ravel()))).float()#Makepredictionsmodel.eval()withtorch.inference_mode():y_logits model(X_to_pred_on)#Testformulti classorbinaryandadjustlogitstopredictionlabelsiflen(torch.unique(y))>2:y_pred torch.softmax(y_logits,dim 1).argmax(dim 1)#mutli classelse:y_pred torch.round(torch.sigmoid(y_logits))#binary#Reshapepredsandploty_pred y_pred.reshape(xx.shape).detach().numpy()plt.contourf(xx,yy,y_pred,cmap plt.cm.RdYlBu,alpha 0.7)plt.scatter(X[:,0],X[:,1],c y,s 40,cmap plt.cm.RdYlBu)plt.xlim(xx.min(),xx.max())plt.ylim(yy.min(),yy.max())plt.figure(figsize (12,6))plt.subplot(1,2,1)plt.title(\"Train\")plot_decision_boundary(model_0,X_train,y_train)plt.subplot(1,2,2)plt.title(\"Test\")plot_decision_boundary(model_0,X_test,y_test)由图可知，模型目前正在尝试用直线分割红点和蓝点。由于我们的数据是圆形的，所以画一条直线最多只能把它从中间切开。在机器学习方面，模型是欠拟合的，这意味着它没有从数据中学习预测模式。##改进模型尝试解决模型的拟合不足问题。 专注于模型（而不是数据）。技巧作用: :: :增加更多隐藏层每一层都可能增加模型的学习能力，每一层都能够学习数据中的某种新模式。更多的层通常被称为使神经网络更深增加更多隐藏神经元与上面类似，每层更多的隐藏单元意味着模型学习能力的潜在增加。更多的隐藏单元通常被称为使你的神经网络更宽增加训练轮数如果模型训练更久，它可能会学到更多改变激活函数有些数据无法仅用直线拟合，使用非线性激活函数可以帮助解决这个问题改变学习率优化器的学习率决定了模型每一步应该改变多少参数，太多了模型会过度校正，太少了模型学习不足改变损失函数不同的问题需要不同的损失函数迁移学习从一个与问题领域相似的问题领域中提取一个预先训练好的模型，并根据问题进行调整###添加非线性classCircleModelV1(nn.Module):def__init__(self):super().__init__()self.layer_1 nn.Linear(in_features 2,out_features 10)self.layer_2 nn.Linear(in_features 10,out_features 10)self.layer_3 nn.Linear(in_features 10,out_features 1)self.relu nn.ReLU()defforward(self,x):returnself.layer_3(self.relu(self.layer_2(self.relu(self.layer_1(x)))))model_1 CircleModelV1().to(device)#model_1 nn.Sequential(#nn.Linear(2,10),#nn.ReLU(),#nn.Linear(10,10),#nn.ReLU(),#nn.Linear(10,1),#).to(device)model_1loss_fn nn.BCEWithLogitsLoss()optimizer torch.optim.SGD(params model_1.parameters(),lr 0.1)重新训练：torch.manual_seed(42)epochs 1500X_train,y_train X_train.to(device),y_train.to(device)X_test,y_test X_test.to(device),y_test.to(device)model_1.to(device)forepochinrange(epochs):model_1.train()y_logits model_1(X_train).squeeze()y_pred torch.round(torch.sigmoid(y_logits))loss loss_fn(y_logits,y_train)acc accuracy_fn(y_true y_train,y_pred y_pred)optimizer.zero_grad()loss.backward()optimizer.step()model_1.eval()withtorch.inference_mode():test_logits model_1(X_test).squeeze()test_pred torch.round(torch.sigmoid(test_logits))test_loss loss_fn(test_logits,y_test)test_acc accuracy_fn(y_true y_test,y_pred test_pred)ifepoch%100 0:print(f\"{epoch}/{epochs}Loss:{loss:.5f},Accu:{acc:.2f}%TestLoss:{test_loss:.5f},TestAccu:{test_acc:.2f}%\")0/1500 Loss: 0.69295, Accu: 50.00% Test Loss: 0.69319, Test Accu: 50.00% 100/1500 Loss: 0.69115, Accu: 52.88% Test Loss: 0.69102, Test Accu: 52.50% 200/1500 Loss: 0.68977, Accu: 53.37% Test Loss: 0.68940, Test Accu: 55.00% 300/1500 Loss: 0.68795, Accu: 53.00% Test Loss: 0.68723, Test Accu: 56.00% 400/1500 Loss: 0.68517, Accu: 52.75% Test Loss: 0.68411, Test Accu: 56.50% 500/1500 Loss: 0.68102, Accu: 52.75% Test Loss: 0.67941, Test Accu: 56.50% 600/1500 Loss: 0.67515, Accu: 54.50% Test Loss: 0.67285, Test Accu: 56.00% 700/1500 Loss: 0.66659, Accu: 58.38% Test Loss: 0.66322, Test Accu: 59.00% 800/1500 Loss: 0.65160, Accu: 64.00% Test Loss: 0.64757, Test Accu: 67.50% 900/1500 Loss: 0.62362, Accu: 74.00% Test Loss: 0.62145, Test Accu: 79.00% 1000/1500 Loss: 0.56818, Accu: 87.75% Test Loss: 0.57378, Test Accu: 86.50% 1100/1500 Loss: 0.48153, Accu: 93.50% Test Loss: 0.49935, Test Accu: 90.50% 1200/1500 Loss: 0.37056, Accu: 97.75% Test Loss: 0.40595, Test Accu: 92.00% 1300/1500 Loss: 0.25458, Accu: 99.00% Test Loss: 0.30333, Test Accu: 96.50% 1400/1500 Loss: 0.17180, Accu: 99.50% Test Loss: 0.22108, Test Accu: 97.50%可视化一下：plt.figure(figsize (12,6))plt.subplot(1,2,1)plt.title(\"Train\")plot_decision_boundary(model_1,X_train,y_train)plt.subplot(1,2,2)plt.title(\"Test\")plot_decision_boundary(model_1,X_test,y_test)现在模型的分类就有了显著的效果。##多分类问题###构建多分类数据集利用Scikit Learn的`make_blobs()`方法。这个方法将创建任意数量的类（使用`centers`参数）。1.使用`make_blobs()`创建一些多类数据。2.将数据转换为张量（`make_blobs()`的默认值是使用NumPy数组）。3.使用`train_test_split()`将数据拆分为训练集和测试集。4.可视化数据。importtorchimportmatplotlib.pyplotaspltfromsklearn.datasetsimportmake_blobsfromsklearn.model_selectionimporttrain_test_splitNUM_CLASSES 4NUM_FEATURES 2RANDOM_SEED 42X_blob,y_blob make_blobs(n_samples 1000,n_features NUM_FEATURES,centers NUM_CLASSES,cluster_std 1.5,random_state RANDOM_SEED)X_blob torch.from_numpy(X_blob).type(torch.float)y_blob torch.from_numpy(y_blob).type(torch.LongTensor)X_blob_train,X_blob_test,y_blob_train,y_blob_test train_test_split(X_blob,y_blob,test_size 0.2,random_state RANDOM_SEED)plt.figure(figsize (10,6))plt.scatter(X_blob[:,0],X_blob[:,1],c y_blob,cmap plt.cm.RdYlBu)###构建多元分类模型创建一个`nn.Module`的子类，接受三个超参数： `input_features`：输入特征的数量。 `output_features`：输出特征数（等效于`NUM_CLASSES`或多类分类问题中的类数）。 `hidden_units`：每个隐藏层使用的隐藏神经元的数量。device \"cuda\"iftorch.cuda.is_available()else\"cpu\"fromtorchimportnnclassBlobModel(nn.Module):def__init__(self,input_features,output_features,hidden_units 8):super().__init__()self.model nn.Sequential(nn.Linear(in_features input_features,out_features hidden_units),nn.ReLU(),nn.Linear(in_features hidden_units,out_features hidden_units),nn.ReLU(),nn.Linear(in_features hidden_units,out_features output_features))defforward(self,x):returnself.model(x)model_2 BlobModel(input_features NUM_FEATURES,output_features NUM_CLASSES,hidden_units 8).to(device)model_2###构建多元分类损失函数和优化器loss_fn nn.CrossEntropyLoss()optimizer torch.optim.SGD(model_2.parameters(),lr 0.1)试着看看模型前向输出：y_logits model_2(X_blob_train.to(device))[:5]y_logits再看看经过激活函数Softmax之后的结果：y_pred_probs torch.softmax(y_logits,dim 1)y_pred_probs经过Softmax函数之后，先前的数字变成预测到某类的概率。这些预测概率本质上是说模型认为目标样本（输入）映射到每个类的程度。由于y_pred_probs中的每个类都有一个值，因此最高值的索引是模型认为特定数据样本最属于的类。可以使用`torch.argmax()`检查哪个索引具有最高值。torch.argmax(y_pred_probs[0])###构建多分类训练和测试循环torch.manual_seed(42)epochs 100X_blob_train,y_blob_train X_blob_train.to(device),y_blob_train.to(device)X_blob_test,y_blob_test X_blob_test.to(device),y_blob_test.to(device)model_2.to(device)forepochinrange(epochs):model_2.train()y_logits model_2(X_blob_train)y_pred torch.softmax(y_logits,dim 1).argmax(dim 1)loss loss_fn(y_logits,y_blob_train)acc accuracy_fn(y_true y_blob_train,y_pred y_pred)optimizer.zero_grad()loss.backward()optimizer.step()model_2.eval()withtorch.inference_mode():test_logits model_2(X_blob_test)test_pred torch.softmax(test_logits,dim 1).argmax(dim 1)test_loss loss_fn(test_logits,y_blob_test)tess_acc accuracy_fn(y_true y_blob_test,y_pred test_pred)ifepoch%10 0:print(f\"{epoch}/{epochs}Loss:{loss:.5f},Acc:{acc:.2f}%TestLoss:{test_loss:.5f},TestAcc:{test_acc:.2f}%\")0/100 Loss: 1.15883, Acc: 40.38% Test Loss: 1.07554, Test Acc: 99.00% 10/100 Loss: 0.64476, Acc: 96.75% Test Loss: 0.66069, Test Acc: 99.00% 20/100 Loss: 0.42535, Acc: 98.50% Test Loss: 0.43074, Test Acc: 99.00% 30/100 Loss: 0.25294, Acc: 99.12% Test Loss: 0.24508, Test Acc: 99.00% 40/100 Loss: 0.11232, Acc: 99.25% Test Loss: 0.10229, Test Acc: 99.00% 50/100 Loss: 0.06627, Acc: 99.25% Test Loss: 0.05848, Test Acc: 99.00% 60/100 Loss: 0.05068, Acc: 99.25% Test Loss: 0.04293, Test Acc: 99.00% 70/100 Loss: 0.04300, Acc: 99.25% Test Loss: 0.03491, Test Acc: 99.00% 80/100 Loss: 0.03836, Acc: 99.25% Test Loss: 0.02988, Test Acc: 99.00% 90/100 Loss: 0.03525, Acc: 99.25% Test Loss: 0.02663, Test Acc: 99.00%###评估多分类模型使用准确率评估：model_2.eval()withtorch.inference_mode():y_logits model_2(X_blob_test)y_preds torch.softmax(y_logits,dim 1).argmax(dim 1)print(f\"Testaccuracy:{accuracy_fn(y_true y_blob_test,y_pred y_preds)}%\")Test accuracy: 99.5%可视化评估：plt.figure(figsize (12,6))plt.subplot(1,2,1)plt.title(\"Train\")plot_decision_boundary(model_2,X_blob_train,y_blob_train)plt.subplot(1,2,2)plt.title(\"Test\")plot_decision_boundary(model_2,X_blob_test,y_blob_test)##更多分类评估指标评估指标定义代码: :: :: :正确率模型预测正确的占比`torchmetrics.Accuracy()`或`sklearn.metrics.accuracy_score()`精确率$\\text{Precision} \\frac{TP}{TP+FP}$`torchmetrics.Precision()`或`sklearn.metrics.precision_score()`召回率$\\text{Recall} \\frac{TP}{TP+FN}$`torchmetrics.Recall()`或`sklearn.metrics.recall_score()`F1 Score将查准率和查全率合并为一个指标。1是最好的，0是最坏的`torchmetrics.F1Score()`或`sklearn.metrics.f1_score()`混淆矩阵以表格方式将预测值与真实值进行比较，如果100%正确，矩阵中的所有值将从左上角到右下角（对角线）`torchmetrics.ConfusionMatrix`或`sklearn.metrics.plot_confusion_matrix()`分类报告一些主要分类指标的集合，如精度，召回率和f1分数`sklearn.metrics.classification_report()`"},"/StyleTransfer/ref-and-notes/pytorch-install.html":{"title":"PyTorch 安装","content":" title: PyTorch 安装 keywords: PyTorch desc: PyTorch 安装 date: 2025 02 07 id: pytorch Reference: [Zero to Mastery Learn PyTorch for Deep Learning](https://www.learnpytorch.io/) ## PyTorch 基本环境搭建 1. 创建并激活环境 ```bat python m venv [venv name] [venv name]\\Scripts\\activate ``` 2. 安装 Pytorch ```bat pip install torch torchvision torchaudio ``` 验证 Pytorch 安装，出现版本号则为正常。 ## PyTorch GPU 环境搭建 在搭建虚拟环境后，如果需要在 GPU 上运行，需要安装 PyTorch GPU 版本。 1. 确定自己的 GPU CUDA 版本。 ```bat nvidia smi ``` 2. 下载对应的 PyTorch GPU 版本。[官方引导下载](https://pytorch.org/get started/locally/) 附镜像页面链接： PyTorch官方镜像 [Torch](https://download.pytorch.org/whl/torch/) [TorchVision](https://download.pytorch.org/whl/torchvision/) [TorchAudio](https://download.pytorch.org/whl/torchaudio/) [阿里云镜像源](https://mirrors.aliyun.com/pytorch wheels/) 支持的 CUDA：10.0、10.1、10.2、11.0、11.1、11.3、11.5、11.6、11.7、11.8、12.1 3. 检测是否可用。 ```python import torch print(torch.cuda.is_available()) ```"},"/StyleTransfer/ref-and-notes/pytorch-tensor.html":{"title":"PyTorch 张量","content":"Reference:[ZerotoMasteryLearnPyTorchforDeepLearning](https://www.learnpytorch.io/)*该页面为JupyterNotebook生成，原文件于[Github](https://github.com/Fingsinz/StyleTransfer/tree/main/src/02.pytorch_learning/pytorch tensor.ipynb)*importtorchtorch.__version__##什么是张量张量用于表示数据，是机器学习的基本组成部分。 图片可以是三维张量，如`[height,width,channel]`，如经典的lena图片用张量表示：importnumpyasnpfromPILimportImage#使用pillow打开图片,转换为numpy矩阵,再转换为torch张量img torch.from_numpy(np.array(Image.open(\"imgs/lena.jpg\")))img.shape##创建张量Tensors说明文档：[https://pytorch.org/docs/stable/tensors.html](https://pytorch.org/docs/stable/tensors.html)1.Scalar，标量是一个单独的数字，用张量的术语来说是一个零维张量。scalar torch.tensor(3.0)#维度同样可以通过tensor.dim()获取print(f\"scalar为{scalar},维度为{scalar.ndim},常量通过item方法获取{scalar.item()}数字\")scalar为3.0, 维度为0, 常量通过item方法获取3.0数字2.Vector，向量是一个一维张量，类似于数组。vector torch.tensor([1.0,2.0,3.0])print(f\"vector为{vector},维度为{vector.ndim},通过shape属性获取形状{vector.shape}\")vector为tensor([1., 2., 3.]), 维度为1, 通过shape属性获取形状torch.Size([3])3.Matrix，矩阵是一个二维张量。matrix torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]])print(f\"{matrix},\\n维度为{matrix.ndim},通过shape属性获取形状{matrix.shape}\")tensor([[1., 2., 3.], [4., 5., 6.]]), 维度为2, 通过shape属性获取形状torch.Size([2, 3])总结：结构表示维度: :: :: :scalar一个数字0vector一组数字1matrix一个矩阵2tensor若干维度0维表示scalar，每一维表示一个vector###`torch.rand()`生成随机张量实际上在机器学习中很少会手动创建张量，更多是随机生成。#创建指定大小的随机张量random_tensor torch.rand(size (3,4))random_tensor,random_tensor.dtype###填充全零或全一张量zeros torch.zeros(size (3,4))ones torch.ones(size (3,4))zeros,zeros.dtypeones,ones.dtype###创建一个范围张量#创建一个从0到9的张量的两种方法#zero_to_ten1 torch.range(0,10)#将弃用zero_to_ten2 torch.arange(start 0,end 10,step 1)#zero_to_ten1,zero_to_ten1.dtypezero_to_ten2,zero_to_ten2.dtype#创建一个形状一样的向量same_shape torch.zeros_like(input zero_to_ten2)same_shape,same_shape.dtype##张量数据类型Tensor的DataTypes：[https://pytorch.org/docs/stable/tensors.html#data types](https://pytorch.org/docs/stable/tensors.html#data types)有些数据类型是特定于CPU，而有些更适合GPU。同时确保精度问题，可以选用不同精度的浮点数类型。float32_tensor torch.tensor([3.0,6.0,9.0],dtype None,#默认为None，即torch。Float32或传递的任何数据类型device None,#默认为None，使用默认的张量类型requires_grad False)#如果为True，则记录对张量执行的操作float32_tensor.shape,float32_tensor.dtype,float32_tensor.device可以修改张量的数据类型：float64_tensor float32_tensor.type(torch.float64)float64_tensor.dtype在进行带张量的操作时，除了张量的Shape要匹配之外，还需要注意张量的dtype和device。 `tensor.shape`：获取Shape。 `tensor.dtype`：获取dtype。 `tensor.device`：获取device。##张量的操作###张量的基础操作张量的加减乘操作如下：test_tensor torch.tensor([1,2,3])test_tensor+10,test_tensor*10,test_tensor 1,test_tensor#在不赋值的时候是不变的也可以通过函数实现：torch.add(test_tensor,10),torch.mul(test_tensor,10),torch.sub(test_tensor,1)注意，**矩阵乘法遵循其规则，与形状相关。**$$M_{m\\timesn} M_{m\\timesk}@M_{k\\timesn}$$*`@`在Python中是矩阵乘法*tensor torch.tensor([1,2,3])tensor*tensor,tensor@tensor,torch.matmul(tensor,tensor)#torch.matmul是矩阵乘法，且比@操作更快 $[1,2,3]*[1,2,3] [1*1,2*2,3*3] [1,4,9]$ $[1,2,3]@[1,2,3] 1*1+2*2+3*3 14$`torch.mm()`是`torch.matmul()`的缩写。另外提供一些操作进行矩阵变换： `torch.transpose(input,dim0,dim1)`，`input`是输入矩阵，`dim0`和`dim1`是要交换的维度。 `torch.T`：转置矩阵。###求最小值、最大值、平均值、总和等x torch.arange(0,100,10)print(x)print(f\"最小值:{x.min()}\")print(f\"最大值:{x.max()}\")#print(f\"Mean:{x.mean()}\")#会报错print(f\"均值:{x.type(torch.float32).mean()}\")#没有float数据类型将无法工作print(f\"总和:{x.sum()}\")tensor([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) 最小值: 0 最大值: 90 均值: 45.0 总和: 450*一些方法，如torch.mean()，要求张量位于torch.float32（最常见）或其他特定数据类型中，否则操作将失败。*###求最小最大值的位置print(x)print(f\"Indexwheremaxvalueoccurs:{x.argmax()}\")print(f\"Indexwhereminvalueoccurs:{x.argmin()}\")tensor([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) Index where max value occurs: 9 Index where min value occurs: 0###张量形状重塑、堆叠、挤压和扩展因为深度学习模型（神经网络）都是关于以某种方式操纵张量的。因为矩阵乘法的规则，如果有形状不匹配，就会遇到错误。这些方法帮助你确保你的张量的正确元素与其他张量的正确元素混合在一起。方法描述: :: :[torch.reshape(input,shape)](https://pytorch.org/docs/stable/generated/torch.reshape.html#torch.reshape)或`torch.Tensor.reshape()`在兼容的情况下把`input`重塑成`shape`的形状[Tensor.view(shape)](https://pytorch.org/docs/stable/generated/torch.Tensor.view.html)以不同的形状返回原始张量的视图，但与原始张量共享相同的数据[torch.stack(tensors,dim 0)](https://pytorch.org/docs/1.9.1/generated/torch.stack.html)沿着一个新的维度`dim`连接一系列张量，所有张量必须是相同的大小[torch.squeeze(input)](https://pytorch.org/docs/stable/generated/torch.squeeze.html)挤压`input`，删除值为1的所有维度[torch.unsqueeze(input,dim)](https://pytorch.org/docs/1.9.1/generated/torch.unsqueeze.html)在`dim`处添加值为1的维度并返回[torch.permute(input,dims)](https://pytorch.org/docs/stable/generated/torch.permute.html)返回原始输入的视图，其维度重新排列`tensor.reshape()`：importtorchx torch.arange(1.,9.)x_reshaped x.reshape(1,8)#重塑print(f\"x.shape:{x.shape},x_reshaped.shape:{x_reshaped.shape}\")x.shape: torch.Size([8]), x_reshaped.shape: torch.Size([1, 8])`tensor.view()`：改变视图也会改变原来的张量。x_viewed x.view(2,4)#重塑print(f\"x.shape:{x.shape},x_viewed.shape:{x_viewed.shape}\")#修改x_viewd,x同步变化x_viewed[:,0] 5print(x)print(x_viewed)x.shape: torch.Size([8]), x_viewed.shape: torch.Size([2, 4]) tensor([5., 2., 3., 4., 5., 6., 7., 8.]) tensor([[5., 2., 3., 4.], [5., 6., 7., 8.]])用该函数改变一个张量的视图实际上只会创建同一个张量的新视图。如果想要将新张量在自身之上堆叠五次，可以使用`torch.stack()`来实现。x_stacked torch.stack([x,x,x,x],dim 0)x_stacked同时可以移除单维度：print(x_reshaped.shape)x_squzzed x_reshaped.squeeze()print(x_squzzed.shape)torch.Size([1, 8]) torch.Size([8])与`torch.squeeze()`相反，可以使用`torch.unsqueeze()`在特定索引处添加一个维度值1：print(x_squzzed.shape)x_unsquzzed x_squzzed.unsqueeze(dim 0)print(x_unsquzzed.shape)torch.Size([8]) torch.Size([1, 8])`torch.permute(input,dims)`重排张量的维度：img torch.rand(size (128,256,3))img_permuted img.permute(2,0,1)img.shape,img_permuted.shape###张量取下标importtorchx torch.arange(1,10).reshape(1,3,3)print(f\"{x},{x.shape}\")print(f\"x[0]:\\n{x[0]}\")print(f\"x[0][0]:{x[0][0]}\")print(f\"x[0][0][0]:{x[0][0][0]}\")tensor([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]), torch.Size([1, 3, 3]) x[0]: tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) x[0][0]: tensor([1, 2, 3]) x[0][0][0]: 1*可以使用`:`来指定此维度中的所有值，使用逗号`,`来添加另一个维度。*##Pytorch张量和NumpyNumPy和PyTorch数据结构互转： NumpyArray >PyTorchTensor：`torch.from_numpy(ndarray)`。 PyTorchTensor >NumpyArray：`torch.Tensor.numpy()`。##Tensor随机值`torch.rand()`方法可以生成一个给定大小而值随机的张量，但是每次生成都会不一样。如果需要每次随机都一样，需要固定下随机数种子。importtorchimportrandomRANDOM_SEED 42torch.manual_seed(seed RANDOM_SEED)random_tensor_A torch.rand(3,4)torch.random.manual_seed(seed RANDOM_SEED)random_tensor_B torch.rand(3,4)print(f\"TensorA:\\n{random_tensor_A}\\n\")print(f\"TensorB:\\n{random_tensor_B}\\n\")print(f\"A B?\")print(random_tensor_A random_tensor_B)Tensor A: tensor([[0.8823, 0.9150, 0.3829, 0.9593], [0.3904, 0.6009, 0.2566, 0.7936], [0.9408, 0.1332, 0.9346, 0.5936]]) Tensor B: tensor([[0.8823, 0.9150, 0.3829, 0.9593], [0.3904, 0.6009, 0.2566, 0.7936], [0.9408, 0.1332, 0.9346, 0.5936]]) A B? tensor([[True, True, True, True], [True, True, True, True], [True, True, True, True]])##GPU下使用张量导入PyTorch：importtorchtorch.cuda.is_available()设置设备类型：#Setdevicetypedevice \"cuda\"iftorch.cuda.is_available()else\"cpu\"device检查设备数：torch.cuda.device_count()###张量在CPU和GPU间移动通过调用`to(device)`将张量（和模型）放在特定的设备上。GPU可以提供比CPU更快的数值计算，但有时候某些操作不支持在GPU中执行，所以需要将张量进行移动。张量移动到GPU侧：tensor torch.tensor([1,2,3])print(tensor,tensor.device)tensor_on_gpu tensor.to(device)print(tensor_on_gpu)tensor([1, 2, 3]) cpu tensor([1, 2, 3], device 'cuda:0')张量移动到CPU侧：通过使用`tensor.CPU()`tensor_back_on_cpu tensor_on_gpu.cpu()print(tensor_back_on_cpu)#上面的代码返回CPU内存中GPU张量的副本，原始张量仍然在GPU上。print(tensor_on_gpu)tensor([1, 2, 3]) tensor([1, 2, 3], device 'cuda:0')"},"/StyleTransfer/ref-and-notes/index.html":{"title":"参考文献及笔记","content":" title: 参考文献及笔记 keywords: desc: 参考文献阅读及其代码测试 date: 2025 01 16 1. 原始GAN: [Generative Adversarial Networks](https://arxiv.org/abs/1406.2661)"}}